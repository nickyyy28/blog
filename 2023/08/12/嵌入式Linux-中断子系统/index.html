<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>嵌入式Linux-中断子系统 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1. 中断系统CPU在运行时有一些操作是不定时的, 例如用户是否按下按钮, 是否触摸屏幕, 这些操作cpu无法预知什么时候来临, 所以, 为了及时读取这些信息, 产生了三种方法:  阻塞: CPU不知道什么时候事件会来, 所以一直停止运行, 等待事件到来 轮询: CPU执行自己的程序, 每隔一段时间查看是否有事件到来 中断: CPU一直执行自己的程序, 直到外部事件到来通知CPU, CPU停止执行">
<meta property="og:type" content="article">
<meta property="og:title" content="嵌入式Linux-中断子系统">
<meta property="og:url" content="http://example.com/2023/08/12/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1. 中断系统CPU在运行时有一些操作是不定时的, 例如用户是否按下按钮, 是否触摸屏幕, 这些操作cpu无法预知什么时候来临, 所以, 为了及时读取这些信息, 产生了三种方法:  阻塞: CPU不知道什么时候事件会来, 所以一直停止运行, 等待事件到来 轮询: CPU执行自己的程序, 每隔一段时间查看是否有事件到来 中断: CPU一直执行自己的程序, 直到外部事件到来通知CPU, CPU停止执行">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pic.imgdb.cn/item/64d79f961ddac507cc889613.png">
<meta property="og:image" content="https://pic.imgdb.cn/item/64d79fa81ddac507cc88ce64.png">
<meta property="og:image" content="https://pic.imgdb.cn/item/64d7a2d51ddac507cc91d664.png">
<meta property="og:image" content="http://example.com/assets/image-20221026155734031.png">
<meta property="article:published_time" content="2023-08-12T15:19:43.000Z">
<meta property="article:modified_time" content="2023-08-12T15:23:27.916Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Linux内核">
<meta property="article:tag" content="ARM">
<meta property="article:tag" content="中断">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/64d79f961ddac507cc889613.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-嵌入式Linux-中断子系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/12/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2023-08-12T15:19:43.000Z" itemprop="datePublished">2023-08-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/">嵌入式开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      嵌入式Linux-中断子系统
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-中断系统"><a href="#1-中断系统" class="headerlink" title="1. 中断系统"></a>1. 中断系统</h2><p><strong>CPU在运行时有一些操作是不定时的, 例如用户是否按下按钮, 是否触摸屏幕, 这些操作cpu无法预知什么时候来临, 所以, 为了及时读取这些信息, 产生了三种方法:</strong></p>
<ul>
<li><strong>阻塞: CPU不知道什么时候事件会来, 所以一直停止运行, 等待事件到来</strong></li>
<li><strong>轮询: CPU执行自己的程序, 每隔一段时间查看是否有事件到来</strong></li>
<li><strong>中断: CPU一直执行自己的程序, 直到外部事件到来通知CPU, CPU停止执行当前程序去执行中断服务函数</strong></li>
</ul>
<p><strong>上面三种处理方式中, 第一种几乎不会使用, 完全没有效率, 占用CPU资源, 无法执行其他程序, 第二种也很少使用, 当外部事件数量多的时候就要花大量的时间去查询, 浪费CPU时间, 现在主流都是用第三种方式: 中断</strong></p>
<p><strong>Linux在不断的演化中, 逐渐形成了一套中断系统, 通过Linux系统的api, 用户可以方便的定义中断</strong></p>
<h2 id="2-GIC-generic-interrupt-controller"><a href="#2-GIC-generic-interrupt-controller" class="headerlink" title="2. GIC(generic interrupt controller)"></a>2. GIC(generic interrupt controller)</h2><div align="center"><i>注: 部分内容引用自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/443815199" >https://zhuanlan.zhihu.com/p/443815199</a></i></div>

<p><strong>GIC 是 ARM 公司给 Cortex-A&#x2F;R 内核提供的一个中断控制器，类似 Cortex-M 内核（STM32）中的 NVIC。目前 GIC 有 4 个版本:V1<del>V4，V1 是最老的版本，已经被废弃了。V2</del>V4 目前正在大量的使用。GIC V2 是给 ARMv7-A 架构使用的，比如 Cortex-A7、Cortex-A9、Cortex-A15 等， V3 和 V4 是给 ARMv8-A&#x2F;R 架构使用的，也就是 64 位芯片使用的。</strong></p>
<p><strong>GIC控制器与CPU和其他外设相连的拓扑图如下:</strong></p>
<p><img src="https://pic.imgdb.cn/item/64d79f961ddac507cc889613.png" alt="image-20221024150313954"></p>
<p><strong>UART, Timer, FLASH, 等外设的数据线通过SMBA总线相连与CPU进行数据通信, 中断信息不通过该总线发送至CPU, 而是发送给与之相连的GIC控制器</strong></p>
<p><strong>GIC控制器根据中断的优先级, 是否使能进行仲裁后, 发送给对应的CPU</strong></p>
<p><img src="https://pic.imgdb.cn/item/64d79fa81ddac507cc88ce64.png" alt="image-20221024152802258"></p>
<p><strong>左侧部分就是中断源，中间部分就是 GIC 控制器，最右侧就是中断控制器向 处理器内核发送中断信息。我们重点要看的肯定是中间的 GIC 部分，GIC 将众多的中断源分为 分为三类：</strong></p>
<ul>
<li><strong>1. SPI(Shared Peripheral Interrupt)，共享外设中断，该中断来自于外设，所有 Core 共享的中断。比如按键中断、串口中断等等，这些中断所有的 Core 都可以处理，不限定特定 Core。</strong></li>
<li><strong>2. PPI(Private Peripheral Interrupt)，私有外设中断，该终端来自于外设，被特定的核处理。 GIC 是支持多核的，每个核有自己独有的中断。</strong></li>
<li><strong>3. SGI(Software-generated Interrupt)，软中断，由软件触发引起的中断，通过向寄存器 GICD_SGIR 写入数据来触发，系统会使用 SGI 中断来完成多核之间的通信。</strong></li>
</ul>
<p><strong>中断源有很多，为了区分这些不同的中断源肯定要给他们分配一个唯一 ID，这些 ID 就是中断 ID。</strong><br><strong>GIC-v2中 每一个 CPU 最多支持 1020 个中断 ID，中断 ID 号为 ID0~ID1019。这 1020 个 ID 包 含了 PPI、SPI 和 SGI。这 1020 个 ID 分 配如下：</strong></p>
<ul>
<li>ID0~ID15：这 16 个 ID 分配给 SGI。每个CPU核都有自己的16个。</li>
<li>ID16~ID31：这 16 个 ID 分配给 PPI。 每个CPU核都有自己的16个。</li>
<li>ID32~ID1019：这 988 个 ID 分配给 SPI，像 GPIO 中断、串口中断等这些外部中断 ，至于具体到某个 ID 对应哪个中断那就由半导体厂商根据实际情况去定义。</li>
</ul>
<p><strong>GIC-v2 架构分为了两个逻辑块：Distributor 和 CPU Interface，也就是分发器端和 CPU 接口端。</strong></p>
<ul>
<li><strong>Distributor(分发器端)：</strong>中间那个，此逻辑块负责处理各个中断事件的分发问题，也就是中断事件应该发送到哪个 CPU Interface 上去。分发器收集所有的中断源，可以控制每个中断的优先级，它总是将优先级最高的中断事件发送到 CPU 接口端。分发器端要做的主要 工作如下：<ul>
<li>全局中断使能控制。</li>
<li>控制每一个中断的使能或者关闭。</li>
<li>设置每个中断的优先级。</li>
<li>设置每个中断的目标处理器列表。</li>
<li>设置每个外部中断的触发模式：电平触发或边沿触发。</li>
<li>设置每个中断属于组 0 还是组 1。</li>
</ul>
</li>
<li>**CPU Interface(CPU 接口端)**：CPU 接口端听名字就知道是和 CPU Core 相连接的，因此在图中每个 CPU Core 都可以在 GIC 中找到一个与之对应的 CPU Interface。CPU 接口端 就是分发器和 CPU Core 之间的桥梁，CPU 接口端主要工作如下：<ul>
<li>使能或者关闭发送到 CPU Core 的中断请求信号。</li>
<li>应答中断。</li>
<li>通知中断处理完成。</li>
<li>设置优先级掩码，通过掩码来设置哪些中断不需要上报给 CPU Core。</li>
<li>定义抢占策略。</li>
<li>当多个中断到来的时候，选择优先级最高的中断通知给 CPU Core。</li>
</ul>
</li>
</ul>
<h2 id="3-GIC控制器中断流程"><a href="#3-GIC控制器中断流程" class="headerlink" title="3. GIC控制器中断流程"></a>3. GIC控制器中断流程</h2><p><strong>在GIC控制器中, 一个中断源的状态有四个:</strong></p>
<ul>
<li><strong>1. Inactive</strong></li>
<li><strong>2. Pending</strong></li>
<li><strong>3. Active</strong></li>
<li><strong>4. Active and Pending</strong></li>
</ul>
<h3 id="中断处理流程"><a href="#中断处理流程" class="headerlink" title="中断处理流程"></a>中断处理流程</h3><ul>
<li><strong>1. 所有的中断源状态一开始都为Inactive, GIC检测到使能的中断发生，将中断状态设为 pending</strong></li>
<li><strong>2. GIC的仲裁器将最高优先级的pending中断发送到指 定的CPU interface</strong></li>
<li><strong>3.  CPU interface根据配置，将中断信号发送到CPU</strong></li>
<li><strong>4. CPU应答该中断，读取寄存器获取interrupt ID，GIC 更新中断状态为active</strong></li>
<li><strong>5. CPU处理完中断后，发送EOI信号给GIC</strong></li>
</ul>
<p><strong>中断状态转移图如下:</strong></p>
<p><img src="https://pic.imgdb.cn/item/64d7a2d51ddac507cc91d664.png" alt="image-20221025111953399"></p>
<h2 id="4-裸机中断"><a href="#4-裸机中断" class="headerlink" title="4. 裸机中断"></a>4. 裸机中断</h2><p><strong>Cortex-A&#x2F;R系列的cpu和Cortex-M系列cpu中断的定义类似, 但是也有一定的区别</strong></p>
<p><strong>在M系列的产品中, 类似于stm32等32位单片机的中断定义在startup.s的启动文件中, 这个文件中定义了一个中断向量表, cpu的中断控制器(NVIC)接收到中断后会根据中断号去中断向量表中查询对应的函数并跳转执行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">__Vectors       DCD     __initial_sp               ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler              ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler          ; Hard Fault Handler</span><br><span class="line">                DCD     MemManage_Handler          ; MPU Fault Handler</span><br><span class="line">                DCD     BusFault_Handler           ; Bus Fault Handler</span><br><span class="line">                DCD     UsageFault_Handler         ; Usage Fault Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                ...</span><br><span class="line">                DCD     SPI6_IRQHandler            ; SPI6</span><br><span class="line">                DCD     SAI1_IRQHandler            ; SAI1</span><br><span class="line">                DCD      0                         ; Reserved</span><br><span class="line">                DCD      0                         ; Reserved</span><br><span class="line">                DCD     DMA2D_IRQHandler           ; DMA2D</span><br><span class="line">                                         </span><br><span class="line">__Vectors_End</span><br></pre></td></tr></table></figure>

<p><strong>而在A&#x2F;R系列的cpu中, 编写逻辑中断也类似需要提供一个启动文件, 在该文件定义中断向量表:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.section .isr_vector</span><br><span class="line">_Reset:</span><br><span class="line">	B reset_handler</span><br><span class="line">	B .</span><br><span class="line">	B c_svc</span><br><span class="line">	B .</span><br><span class="line">	B .</span><br><span class="line">	B .</span><br><span class="line">	B c_irq</span><br><span class="line">	B c_fiq</span><br><span class="line">.text</span><br></pre></td></tr></table></figure>

<p><strong>不过和stm32不同的是, 不需要把类似于串口中断, IIC中断, DMA中断之类的具体外设的中断函数写入, 只需要提供几个不同CPU模式的中断函数, 如IRQ模式中断函数, FIQ模式,SVC模式等等, 具体的外设中断由程序员自己软件定义的跳转过程实现</strong></p>
<p><strong>在下面的rtc时钟例子中, 有一个函数指针数组, 该数组保存了根据中断号为下标的中断服务函数, 启动文件中的irq中断函数会去gic控制器的寄存器中查询中断发生的中断号, 然后根据中断号作为下标去中断服务函数数组中获取对应的函数并执行</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过__attribute__((interrupt(&quot;IRQ&quot;)))告诉编译器这个是一个中断函数, 编译器会添加相关的上下文保护代码</span></span><br><span class="line"><span class="type">void</span> __attribute__ ((interrupt(<span class="string">&quot;IRQ&quot;</span>))) c_irq(<span class="type">void</span>)&#123;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;cpsid i&quot;</span> : : : <span class="string">&quot;memory&quot;</span>, <span class="string">&quot;cc&quot;</span>)</span>;</span><br><span class="line">	<span class="type">int</span> irq_num = GIC_AcknowledgePending();	<span class="comment">//从GIC控制器中获取中断号</span></span><br><span class="line">	GIC_ClearPendingIRQ(irq_num);			<span class="comment">//清除中断状态</span></span><br><span class="line">	<span class="keyword">if</span>(isr_table[irq_num] != <span class="literal">NULL</span>)&#123;			<span class="comment">//如果在中断服务函数数组中查找到对应的函数则执行</span></span><br><span class="line">		isr_table[irq_num]();</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;no handler found for %d\n&quot;</span>,irq_num);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//向GIC控制器发送中断结束信号</span></span><br><span class="line">	GIC_EndInterrupt(irq_num);</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;cpsie i&quot;</span> : : : <span class="string">&quot;memory&quot;</span>, <span class="string">&quot;cc&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>中断号的定义具体到某个 ID 对应哪个中断由半导体厂商根据实际情况去定义了。在实际使用的过程中需要查询相应的芯片手册</strong></p>
<h2 id="5-Linux中断介绍"><a href="#5-Linux中断介绍" class="headerlink" title="5. Linux中断介绍"></a>5. Linux中断介绍</h2><p><strong>Linux中断系统和裸机中断本质上差不多, 不过为了实现更加强大的功能, 比裸机实现起来复杂得多</strong></p>
<h3 id="注册中断"><a href="#注册中断" class="headerlink" title="注册中断:"></a>注册中断:</h3><p><strong>Linux内核提供了注册中断服务函数的api</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/linux/interrupt.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * request_irq - Add a handler for an interrupt line</span></span><br><span class="line"><span class="comment"> * @irq:	The interrupt line to allocate</span></span><br><span class="line"><span class="comment"> * @handler:	Function to be called when the IRQ occurs.</span></span><br><span class="line"><span class="comment"> *		Primary handler for threaded interrupts</span></span><br><span class="line"><span class="comment"> *		If NULL, the default primary handler is installed</span></span><br><span class="line"><span class="comment"> * @flags:	Handling flags</span></span><br><span class="line"><span class="comment"> * @name:	Name of the device generating this interrupt</span></span><br><span class="line"><span class="comment"> * @dev:	A cookie passed to the handler function</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This call allocates an interrupt and establishes a handler; see</span></span><br><span class="line"><span class="comment"> * the documentation for request_threaded_irq() for details.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">	    <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除中断服务函数"><a href="#删除中断服务函数" class="headerlink" title="删除中断服务函数"></a>删除中断服务函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/irq/manage.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	free_irq - free an interrupt allocated with request_irq</span></span><br><span class="line"><span class="comment"> *	@irq: Interrupt line to free</span></span><br><span class="line"><span class="comment"> *	@dev_id: Device identity to free</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Remove an interrupt handler. The handler is removed and if the</span></span><br><span class="line"><span class="comment"> *	interrupt line is no longer in use by any driver it is disabled.</span></span><br><span class="line"><span class="comment"> *	On a shared IRQ the caller must ensure the interrupt is disabled</span></span><br><span class="line"><span class="comment"> *	on the card it drives before calling this function. The function</span></span><br><span class="line"><span class="comment"> *	does not return until any executing interrupts for this IRQ</span></span><br><span class="line"><span class="comment"> *	have completed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	This function must not be called from interrupt context.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Returns the devname argument passed to request_irq.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">void</span> *<span class="title function_">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> =</span> irq_to_desc(irq);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *devname;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!desc || WARN_ON(irq_settings_is_per_cpu_devid(desc)))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(desc-&gt;affinity_notify))</span><br><span class="line">		desc-&gt;affinity_notify = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	action = __free_irq(desc, dev_id);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!action)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	devname = action-&gt;name;</span><br><span class="line">	kfree(action);</span><br><span class="line">	<span class="keyword">return</span> devname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Linux中的中断服务函数是以下格式:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数为一个int型的中断号, 以及void*的参数指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">irqreturn_t</span> <span class="params">(*<span class="type">irq_handler_t</span>)</span><span class="params">(<span class="type">int</span>, <span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值为irqreturn_t, 是一个枚举类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">irqreturn</span> &#123;</span></span><br><span class="line">	IRQ_NONE		= (<span class="number">0</span> &lt;&lt; <span class="number">0</span>),</span><br><span class="line">	IRQ_HANDLED		= (<span class="number">1</span> &lt;&lt; <span class="number">0</span>),</span><br><span class="line">	IRQ_WAKE_THREAD		= (<span class="number">1</span> &lt;&lt; <span class="number">1</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">irqreturn</span> <span class="title">irqreturn_t</span>;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-Linux中断流程"><a href="#6-Linux中断流程" class="headerlink" title="6. Linux中断流程"></a>6. Linux中断流程</h2><p><strong>当一个中断到来时, Linux内核的中断流程大致可以分为四部分</strong></p>
<h3 id="驱动注册中断"><a href="#驱动注册中断" class="headerlink" title="驱动注册中断"></a>驱动注册中断</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个简单的rtc时钟pl031的驱动代码</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">rtc_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">irqreturn_t</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    regs = (<span class="type">rtc_reg_t</span> *)ioremap(RTC_BASE, <span class="keyword">sizeof</span>(<span class="type">rtc_reg_t</span>)); </span><br><span class="line">    printk(<span class="string">&quot;rtc_init\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    set_rtc_alarm(regs);</span><br><span class="line">    ret = request_irq(<span class="number">39</span>, rtc_alarm_handler, <span class="number">0</span>, <span class="string">&quot;rtc0-test&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        printk(<span class="string">&quot;request_irq failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div align="center">↓</div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/linux/interrupt.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">	    <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center">↓</div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/irq/manage.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">			 <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params">			 <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span>		<span class="comment">//该结构体指针指向了发生中断时要发生的动作</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span>			<span class="comment">//该中断描述符指针, 这两个变量非常重要</span></span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (irq == IRQ_NOTCONNECTED)</span><br><span class="line">		<span class="keyword">return</span> -ENOTCONN;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Sanity-check: shared interrupts must pass in a real dev-ID,</span></span><br><span class="line"><span class="comment">	 * otherwise we&#x27;ll have trouble later trying to figure out</span></span><br><span class="line"><span class="comment">	 * which interrupt is which (messes up the interrupt freeing</span></span><br><span class="line"><span class="comment">	 * logic etc).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Also IRQF_COND_SUSPEND only makes sense for shared interrupts and</span></span><br><span class="line"><span class="comment">	 * it cannot be set along with IRQF_NO_SUSPEND.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (((irqflags &amp; IRQF_SHARED) &amp;&amp; !dev_id) ||</span><br><span class="line">	    (!(irqflags &amp; IRQF_SHARED) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)) ||</span><br><span class="line">	    ((irqflags &amp; IRQF_NO_SUSPEND) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据软中断号获取中断描述符指针</span></span><br><span class="line">	desc = irq_to_desc(irq);</span><br><span class="line">	<span class="keyword">if</span> (!desc)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!irq_settings_can_request(desc) ||</span><br><span class="line">	    WARN_ON(irq_settings_is_per_cpu_devid(desc)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!thread_fn)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		handler = irq_default_primary_handler;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内核空间中申请一片空间保存中断相关的处理函数</span></span><br><span class="line">	action = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> irqaction), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!action)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	action-&gt;handler = handler;		<span class="comment">//中断处理函数</span></span><br><span class="line">	action-&gt;thread_fn = thread_fn;	<span class="comment">//中断线程化处理函数</span></span><br><span class="line">	action-&gt;flags = irqflags;</span><br><span class="line">	action-&gt;name = devname;</span><br><span class="line">	action-&gt;dev_id = dev_id;</span><br><span class="line"></span><br><span class="line">	retval = irq_chip_pm_get(&amp;desc-&gt;irq_data);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		kfree(action);</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//真正进行注册</span></span><br><span class="line">	retval = __setup_irq(irq, desc, action);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (retval) &#123;</span><br><span class="line">		irq_chip_pm_put(&amp;desc-&gt;irq_data);</span><br><span class="line">		kfree(action-&gt;secondary);</span><br><span class="line">		kfree(action);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SHIRQ_FIXME</span></span><br><span class="line">	<span class="keyword">if</span> (!retval &amp;&amp; (irqflags &amp; IRQF_SHARED)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * It&#x27;s a shared IRQ -- the driver ought to be prepared for it</span></span><br><span class="line"><span class="comment">		 * to happen immediately, so let&#x27;s make sure....</span></span><br><span class="line"><span class="comment">		 * We disable the irq to make sure that a &#x27;real&#x27; IRQ doesn&#x27;t</span></span><br><span class="line"><span class="comment">		 * run in parallel with our fake.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">		disable_irq(irq);</span><br><span class="line">		local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">		handler(irq, dev_id);</span><br><span class="line"></span><br><span class="line">		local_irq_restore(flags);</span><br><span class="line">		enable_irq(irq);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上面的函数使用了两个比较重要的结构体</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_common_data</span>	<span class="title">irq_common_data</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span>		<span class="title">irq_data</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> __percpu	*kstat_irqs;</span><br><span class="line">	<span class="type">irq_flow_handler_t</span>	handle_irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">action</span>;</span>	<span class="comment">/* IRQ action list */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		status_use_accessors;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		core_internal_state__do_not_mess_with_it;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		depth;		<span class="comment">/* nested irq disables */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		wake_depth;	<span class="comment">/* nested wake enables */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		tot_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irq_count;	<span class="comment">/* For detecting broken IRQs */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		last_unhandled;	<span class="comment">/* Aging timer for unhandled count */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irqs_unhandled;</span><br><span class="line">	<span class="type">atomic_t</span>		threads_handled;</span><br><span class="line">	<span class="type">int</span>			threads_handled_last;</span><br><span class="line">	<span class="type">raw_spinlock_t</span>		lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>		*<span class="title">percpu_enabled</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>	*<span class="title">percpu_affinity</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>	*<span class="title">affinity_hint</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_affinity_notify</span> *<span class="title">affinity_notify</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PENDING_IRQ</span></span><br><span class="line">	<span class="type">cpumask_var_t</span>		pending_mask;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		threads_oneshot;</span><br><span class="line">	<span class="type">atomic_t</span>		threads_active;</span><br><span class="line">	<span class="type">wait_queue_head_t</span>       wait_for_threads;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PM_SLEEP</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		nr_actions;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		no_suspend_depth;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		cond_suspend_depth;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		force_resume_depth;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span>	*<span class="title">dir</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_IRQ_DEBUGFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>		*<span class="title">debugfs_file</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*dev_name;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARSE_IRQ</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>		<span class="title">kobj</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">request_mutex</span>;</span></span><br><span class="line">	<span class="type">int</span>			parent_irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*name;</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> &#123;</span></span><br><span class="line">	<span class="type">irq_handler_t</span>		handler;</span><br><span class="line">	<span class="type">void</span>			*dev_id;</span><br><span class="line">	<span class="type">void</span> __percpu		*percpu_dev_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">next</span>;</span></span><br><span class="line">	<span class="type">irq_handler_t</span>		thread_fn;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">thread</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">secondary</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irq;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		thread_flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		thread_mask;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span>	*<span class="title">dir</span>;</span></span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>

<p><strong>内核中也和裸机类似, 定义了一个irq_desc的数组, 用来保存中断处理函数等等</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> <span class="title">irq_desc</span>[<span class="title">NR_IRQS</span>];</span></span><br></pre></td></tr></table></figure>

<p><strong>每个中断都有一个中断描述符, 在上面的函数中构造了一个irqaction, 这个action保存了中断的中断号, 处理函数, 中断线程化处理函数, 设备名称, 设备号等等, 通过软中断号在该数组中找到对应的描述符, 然后将该desc描述符指向该irqaction</strong></p>
<h3 id="CPU硬件自动执行的部分"><a href="#CPU硬件自动执行的部分" class="headerlink" title="CPU硬件自动执行的部分"></a>CPU硬件自动执行的部分</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">指令1</span><br><span class="line">指令2</span><br><span class="line">指令3 &lt;----PC指针</span><br><span class="line">指令4</span><br><span class="line">指令5</span><br></pre></td></tr></table></figure>

<p><strong>当中断来时</strong> </p>
<ul>
<li><strong>CPU会将CPSR寄存器保存至SPSR_irq寄存器</strong></li>
<li><strong>设置CPSR控制器, CPU进入ARM状态, IRQ模式</strong></li>
<li><strong>CPSR中的IRQ位 置1, 硬件自动关闭IRQ</strong></li>
<li><strong>将当前中断地址(返回地址)即指令4地址保存至LR_irq寄存器</strong></li>
<li><strong>设置PC&#x3D;0x00000018, 跳转至中断向量表</strong></li>
</ul>
<p><strong>ARM中断向量表的位置:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//arch/arm/kernel/entry-armv.S</span><br><span class="line">.section .vectors, &quot;ax&quot;, %progbits</span><br><span class="line">.L__vectors_start:</span><br><span class="line">	W(b)	vector_rst</span><br><span class="line">	W(b)	vector_und</span><br><span class="line">	W(ldr)	pc, .L__vectors_start + 0x1000</span><br><span class="line">	W(b)	vector_pabt</span><br><span class="line">	W(b)	vector_dabt</span><br><span class="line">	W(b)	vector_addrexcptn</span><br><span class="line">	W(b)	vector_irq</span><br><span class="line">	W(b)	vector_fiq</span><br></pre></td></tr></table></figure>

<p><strong>通过vector_irq跳转到:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//arch/arm/kernel/entry-armv.S</span><br><span class="line">/*</span><br><span class="line"> * Interrupt dispatcher</span><br><span class="line"> */</span><br><span class="line">	vector_stub	irq, IRQ_MODE, 4</span><br><span class="line"></span><br><span class="line">	.long	__irq_usr			@  0  (USR_26 / USR_32)</span><br><span class="line">	.long	__irq_invalid			@  1  (FIQ_26 / FIQ_32)</span><br><span class="line">	.long	__irq_invalid			@  2  (IRQ_26 / IRQ_32)</span><br><span class="line">	.long	__irq_svc			@  3  (SVC_26 / SVC_32)</span><br><span class="line">	.long	__irq_invalid			@  4</span><br><span class="line">	.long	__irq_invalid			@  5</span><br><span class="line">	.long	__irq_invalid			@  6</span><br><span class="line">	.long	__irq_invalid			@  7</span><br><span class="line">	.long	__irq_invalid			@  8</span><br><span class="line">	.long	__irq_invalid			@  9</span><br><span class="line">	.long	__irq_invalid			@  a</span><br><span class="line">	.long	__irq_invalid			@  b</span><br><span class="line">	.long	__irq_invalid			@  c</span><br><span class="line">	.long	__irq_invalid			@  d</span><br><span class="line">	.long	__irq_invalid			@  e</span><br><span class="line">	.long	__irq_invalid			@  f</span><br></pre></td></tr></table></figure>

<p><strong>该函数又跳转至__irq_usr</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//arch/arm/kernel/entry-armv.S</span><br><span class="line">__irq_usr:</span><br><span class="line">	usr_entry</span><br><span class="line">	kuser_cmpxchg_check</span><br><span class="line">	irq_handler</span><br><span class="line">	get_thread_info tsk</span><br><span class="line">	mov	why, #0</span><br><span class="line">	b	ret_to_user_from_irq</span><br><span class="line"> UNWIND(.fnend		)</span><br><span class="line">ENDPROC(__irq_usr)</span><br></pre></td></tr></table></figure>

<p><strong>该函数又会跳转到irq_handler</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//arch/arm/kernel/entry-armv.S</span><br><span class="line">.macro	irq_handler</span><br><span class="line">#ifdef CONFIG_GENERIC_IRQ_MULTI_HANDLER</span><br><span class="line">	ldr	r1, =handle_arch_irq</span><br><span class="line">	mov	r0, sp</span><br><span class="line">	badr	lr, 9997f</span><br><span class="line">	ldr	pc, [r1]</span><br><span class="line">#else</span><br><span class="line">	arch_irq_handler_default</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p><strong>跳转至arch_irq_handler_default</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//arch/arm/include/asm/entry-macro-multi.S</span><br><span class="line">.macro	arch_irq_handler_default</span><br><span class="line">	get_irqnr_preamble r6, lr</span><br><span class="line">1:	get_irqnr_and_base r0, r2, r6, lr	/*获取IRQ number*/</span><br><span class="line">	movne	r1, sp</span><br><span class="line">	@</span><br><span class="line">	@ routine called with r0 = irq number, r1 = struct pt_regs *</span><br><span class="line">	@</span><br><span class="line">	badrne	lr, 1b</span><br><span class="line">	bne	asm_do_IRQ</span><br></pre></td></tr></table></figure>

<p><strong>该函数根据HW interrupt ID获取IRQ number, 执行asm_do_IRQ</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arch/arm/kernel/irq.c</span></span><br><span class="line">asmlinkage <span class="type">void</span> __exception_irq_entry</span><br><span class="line"><span class="title function_">asm_do_IRQ</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">	handle_IRQ(irq, regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center">↓</div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arch/arm/kernel/irq.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_IRQ</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">	__handle_domain_irq(<span class="literal">NULL</span>, irq, <span class="literal">false</span>, regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center">↓</div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/irq/irqdesc.c</span></span><br><span class="line"><span class="type">int</span> __handle_domain_irq(<span class="keyword">struct</span> irq_domain *domain, <span class="type">unsigned</span> <span class="type">int</span> hwirq,</span><br><span class="line">			<span class="type">bool</span> lookup, <span class="keyword">struct</span> pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> *<span class="title">old_regs</span> =</span> set_irq_regs(regs);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> irq = hwirq;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	irq_enter();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IRQ_DOMAIN</span></span><br><span class="line">	<span class="keyword">if</span> (lookup)</span><br><span class="line">		irq = irq_find_mapping(domain, hwirq);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Some hardware gives randomly wrong interrupts.  Rather</span></span><br><span class="line"><span class="comment">	 * than crashing, do something sensible.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!irq || irq &gt;= nr_irqs)) &#123;</span><br><span class="line">		ack_bad_irq(irq);</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		generic_handle_irq(irq);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	irq_exit();</span><br><span class="line">	set_irq_regs(old_regs);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center">↓</div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/irq/irqdesc.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">generic_handle_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//根据中断号获取中断描述符</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> =</span> irq_to_desc(irq);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span> *<span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!desc)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	data = irq_desc_get_irq_data(desc);</span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE(!in_irq() &amp;&amp; handle_enforce_irqctx(data)))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	generic_handle_irq_desc(desc);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center">↓</div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/linux/irqdesc.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">generic_handle_irq_desc</span><span class="params">(<span class="keyword">struct</span> irq_desc *desc)</span></span><br><span class="line">&#123;</span><br><span class="line">	desc-&gt;handle_irq(desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这个文件描述符的handle_irq函数在系统初始化的时候进行的赋值</strong></p>
<h3 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h3><p><strong>系统启动过程中, 由于有多个GIC控制器, 为了将不同GIC控制器的中断区分, Linux在系统初始化的过程中建立了硬件中断号(HW  Interrupt ID) 到软中断号的映射(IRQ number)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//drivers/irqchip/irq-gic.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gic_irq_domain_map</span><span class="params">(<span class="keyword">struct</span> irq_domain *d, <span class="type">unsigned</span> <span class="type">int</span> irq,</span></span><br><span class="line"><span class="params">				<span class="type">irq_hw_number_t</span> hw)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gic_chip_data</span> *<span class="title">gic</span> =</span> d-&gt;host_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span> *<span class="title">irqd</span> =</span> irq_desc_get_irq_data(irq_to_desc(irq));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (hw) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span> ... <span class="number">15</span>:</span><br><span class="line">		irq_set_percpu_devid(irq);</span><br><span class="line">		irq_domain_set_info(d, irq, hw, &amp;gic-&gt;chip, d-&gt;host_data,</span><br><span class="line">				    handle_percpu_devid_fasteoi_ipi,</span><br><span class="line">				    <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">16</span> ... <span class="number">31</span>:</span><br><span class="line">		irq_set_percpu_devid(irq);</span><br><span class="line">		irq_domain_set_info(d, irq, hw, &amp;gic-&gt;chip, d-&gt;host_data,</span><br><span class="line">				    handle_percpu_devid_irq, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		irq_domain_set_info(d, irq, hw, &amp;gic-&gt;chip, d-&gt;host_data,</span><br><span class="line">				    handle_fasteoi_irq, <span class="literal">NULL</span>, <span class="literal">NULL</span>);	<span class="comment">//重点</span></span><br><span class="line">		irq_set_probe(irq);</span><br><span class="line">		irqd_set_single_target(irqd);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Prevents SW retriggers which mess up the ACK/EOI ordering */</span></span><br><span class="line">	irqd_set_handle_enforce_irqctx(irqd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在前面提到, Linux的软中断号0-15是SGI中断, 16-31属于PPI中断, 32-1020才是编写驱动常用的共享中断</strong></p>
<p><strong>所以主要分析上面的irq_domain_set_info和它传递的handle_fasteoi_irq这两个函数</strong></p>
<h4 id="irq-domain-set-info"><a href="#irq-domain-set-info" class="headerlink" title="irq_domain_set_info"></a>irq_domain_set_info</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/irq/irqdomain.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_domain_set_info</span><span class="params">(<span class="keyword">struct</span> irq_domain *domain, <span class="type">unsigned</span> <span class="type">int</span> virq,</span></span><br><span class="line"><span class="params">			 <span class="type">irq_hw_number_t</span> hwirq, <span class="keyword">struct</span> irq_chip *chip,</span></span><br><span class="line"><span class="params">			 <span class="type">void</span> *chip_data, <span class="type">irq_flow_handler_t</span> handler,</span></span><br><span class="line"><span class="params">			 <span class="type">void</span> *handler_data, <span class="type">const</span> <span class="type">char</span> *handler_name)</span></span><br><span class="line">&#123;</span><br><span class="line">	irq_domain_set_hwirq_and_chip(domain, virq, hwirq, chip, chip_data);</span><br><span class="line">	__irq_set_handler(virq, handler, <span class="number">0</span>, handler_name);	<span class="comment">//重点</span></span><br><span class="line">	irq_set_handler_data(virq, handler_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center">↓</div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/irq/chip.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">__irq_set_handler(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_flow_handler_t</span> handle, <span class="type">int</span> is_chained,</span><br><span class="line">		  <span class="type">const</span> <span class="type">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过irq number获取文件描述符</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> =</span> irq_get_desc_buslock(irq, &amp;flags, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!desc)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	__irq_do_set_handler(desc, handle, is_chained, name);	<span class="comment">//重点</span></span><br><span class="line">	irq_put_desc_busunlock(desc, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center">↓</div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/irq/chip.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__irq_do_set_handler(<span class="keyword">struct</span> irq_desc *desc, <span class="type">irq_flow_handler_t</span> handle,</span><br><span class="line">		     <span class="type">int</span> is_chained, <span class="type">const</span> <span class="type">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!handle) &#123;</span><br><span class="line">		handle = handle_bad_irq;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> irq_data *irq_data = &amp;desc-&gt;irq_data;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IRQ_DOMAIN_HIERARCHY</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * With hierarchical domains we might run into a</span></span><br><span class="line"><span class="comment">		 * situation where the outermost chip is not yet set</span></span><br><span class="line"><span class="comment">		 * up, but the inner chips are there.  Instead of</span></span><br><span class="line"><span class="comment">		 * bailing we install the handler, but obviously we</span></span><br><span class="line"><span class="comment">		 * cannot enable/startup the interrupt at this point.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">while</span> (irq_data) &#123;</span><br><span class="line">			<span class="keyword">if</span> (irq_data-&gt;chip != &amp;no_irq_chip)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Bail out if the outer chip is not set up</span></span><br><span class="line"><span class="comment">			 * and the interrupt supposed to be started</span></span><br><span class="line"><span class="comment">			 * right away.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (WARN_ON(is_chained))</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			<span class="comment">/* Try the parent */</span></span><br><span class="line">			irq_data = irq_data-&gt;parent_data;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span> (WARN_ON(!irq_data || irq_data-&gt;chip == &amp;no_irq_chip))</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Uninstall? */</span></span><br><span class="line">	<span class="keyword">if</span> (handle == handle_bad_irq) &#123;</span><br><span class="line">		<span class="keyword">if</span> (desc-&gt;irq_data.chip != &amp;no_irq_chip)</span><br><span class="line">			mask_ack_irq(desc);</span><br><span class="line">		irq_state_set_disabled(desc);</span><br><span class="line">		<span class="keyword">if</span> (is_chained)</span><br><span class="line">			desc-&gt;action = <span class="literal">NULL</span>;</span><br><span class="line">		desc-&gt;depth = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	desc-&gt;handle_irq = handle;</span><br><span class="line">	desc-&gt;name = name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (handle != handle_bad_irq &amp;&amp; is_chained) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> type = irqd_get_trigger_type(&amp;desc-&gt;irq_data);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We&#x27;re about to start this interrupt immediately,</span></span><br><span class="line"><span class="comment">		 * hence the need to set the trigger configuration.</span></span><br><span class="line"><span class="comment">		 * But the .set_type callback may have overridden the</span></span><br><span class="line"><span class="comment">		 * flow handler, ignoring that we&#x27;re dealing with a</span></span><br><span class="line"><span class="comment">		 * chained interrupt. Reset it immediately because we</span></span><br><span class="line"><span class="comment">		 * do know better.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (type != IRQ_TYPE_NONE) &#123;</span><br><span class="line">			__irq_set_trigger(desc, type);</span><br><span class="line">			desc-&gt;handle_irq = handle;	<span class="comment">//重点, 这里真正将handle赋值给了handle_irq</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		irq_settings_set_noprobe(desc);</span><br><span class="line">		irq_settings_set_norequest(desc);</span><br><span class="line">		irq_settings_set_nothread(desc);</span><br><span class="line">		desc-&gt;action = &amp;chained_action;</span><br><span class="line">		irq_activate_and_startup(desc, IRQ_RESEND);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>到这里, 中断描述符desc-&gt;irq_handle &#x3D; handle_fasteoi_irq;</strong></p>
<h4 id="handle-fasteoi-irq"><a href="#handle-fasteoi-irq" class="headerlink" title="handle_fasteoi_irq"></a>handle_fasteoi_irq</h4><p><img src="/assets/image-20221026155734031.png" alt="image-20221026155734031"></p>
<p><strong>当CPU的中断到来后最终实际执行到了下面这个函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/irq/chip.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_fasteoi_irq</span><span class="params">(<span class="keyword">struct</span> irq_desc *desc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> *<span class="title">chip</span> =</span> desc-&gt;irq_data.chip;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock(&amp;desc-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!irq_may_run(desc))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	desc-&gt;istate &amp;= ~(IRQS_REPLAY | IRQS_WAITING);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If its disabled or no action available</span></span><br><span class="line"><span class="comment">	 * then mask it and get out of here:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!desc-&gt;action || irqd_irq_disabled(&amp;desc-&gt;irq_data))) &#123;</span><br><span class="line">		desc-&gt;istate |= IRQS_PENDING;</span><br><span class="line">		mask_irq(desc);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kstat_incr_irqs_this_cpu(desc);</span><br><span class="line">	<span class="keyword">if</span> (desc-&gt;istate &amp; IRQS_ONESHOT)</span><br><span class="line">		mask_irq(desc);</span><br><span class="line"></span><br><span class="line">	handle_irq_event(desc);	<span class="comment">//重点</span></span><br><span class="line"></span><br><span class="line">	cond_unmask_eoi_irq(desc, chip);</span><br><span class="line"></span><br><span class="line">	raw_spin_unlock(&amp;desc-&gt;lock);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (!(chip-&gt;flags &amp; IRQCHIP_EOI_IF_HANDLED))</span><br><span class="line">		chip-&gt;irq_eoi(&amp;desc-&gt;irq_data);</span><br><span class="line">	raw_spin_unlock(&amp;desc-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center">↓</div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/irq/handle.c</span></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">handle_irq_event</span><span class="params">(<span class="keyword">struct</span> irq_desc *desc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">irqreturn_t</span> ret;</span><br><span class="line"></span><br><span class="line">	desc-&gt;istate &amp;= ~IRQS_PENDING;</span><br><span class="line">	irqd_set(&amp;desc-&gt;irq_data, IRQD_IRQ_INPROGRESS);</span><br><span class="line">	raw_spin_unlock(&amp;desc-&gt;lock);</span><br><span class="line"></span><br><span class="line">	ret = handle_irq_event_percpu(desc);	<span class="comment">//重点</span></span><br><span class="line"></span><br><span class="line">	raw_spin_lock(&amp;desc-&gt;lock);</span><br><span class="line">	irqd_clear(&amp;desc-&gt;irq_data, IRQD_IRQ_INPROGRESS);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center">↓</div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/irq/handle.c</span></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">handle_irq_event_percpu</span><span class="params">(<span class="keyword">struct</span> irq_desc *desc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">irqreturn_t</span> retval;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	retval = __handle_irq_event_percpu(desc, &amp;flags);	<span class="comment">//重点</span></span><br><span class="line"></span><br><span class="line">	add_interrupt_randomness(desc-&gt;irq_data.irq, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!noirqdebug)</span><br><span class="line">		note_interrupt(desc, retval);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center">↓</div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">irqreturn_t</span> __handle_irq_event_percpu(<span class="keyword">struct</span> irq_desc *desc, <span class="type">unsigned</span> <span class="type">int</span> *flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">irqreturn_t</span> retval = IRQ_NONE;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> irq = desc-&gt;irq_data.irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br><span class="line"></span><br><span class="line">	record_irq_time(desc);</span><br><span class="line"></span><br><span class="line">	for_each_action_of_desc(desc, action) &#123;</span><br><span class="line">		<span class="type">irqreturn_t</span> res;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If this IRQ would be threaded under force_irqthreads, mark it so.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (irq_settings_can_thread(desc) &amp;&amp;</span><br><span class="line">		    !(action-&gt;flags &amp; (IRQF_NO_THREAD | IRQF_PERCPU | IRQF_ONESHOT)))</span><br><span class="line">			lockdep_hardirq_threaded();</span><br><span class="line"></span><br><span class="line">		trace_irq_handler_entry(irq, action);</span><br><span class="line">		res = action-&gt;handler(irq, action-&gt;dev_id);		<span class="comment">//这里真正调用了在rtc驱动中注册的中断服务函数</span></span><br><span class="line">		trace_irq_handler_exit(irq, action, res);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (WARN_ONCE(!irqs_disabled(),<span class="string">&quot;irq %u handler %pS enabled interrupts\n&quot;</span>,</span><br><span class="line">			      irq, action-&gt;handler))</span><br><span class="line">			local_irq_disable();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (res) &#123;</span><br><span class="line">		<span class="keyword">case</span> IRQ_WAKE_THREAD:</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Catch drivers which return WAKE_THREAD but</span></span><br><span class="line"><span class="comment">			 * did not set up a thread function</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(!action-&gt;thread_fn)) &#123;</span><br><span class="line">				warn_no_thread(irq, action);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			__irq_wake_thread(desc, action);</span><br><span class="line"></span><br><span class="line">			fallthrough;	<span class="comment">/* to add to randomness */</span></span><br><span class="line">		<span class="keyword">case</span> IRQ_HANDLED:</span><br><span class="line">			*flags |= action-&gt;flags;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		retval |= res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-Linux中断的上半部和下半部"><a href="#7-Linux中断的上半部和下半部" class="headerlink" title="7. Linux中断的上半部和下半部"></a>7. Linux中断的上半部和下半部</h2><p><strong>Linux的中断处理可以分为上半部和下半部, 因为当中断来的时候, 既要进行寄存器的配置, 同时也要处理数据, 由于Linux是一个多任务系统, 如果在中断中进行大量的数据处理工作, 必然会导致其他任务无法被抢占, 使系统卡顿, 于是Linux便演化出了中断的上下半部</strong></p>
<h3 id="上半部"><a href="#上半部" class="headerlink" title="上半部"></a>上半部</h3><p><strong>响应中断，硬件配置，发送EOI给GIC</strong></p>
<h3 id="下半部"><a href="#下半部" class="headerlink" title="下半部"></a>下半部</h3><p><strong>数据复制、数据包封装转发、编解码…</strong></p>
<p><strong>Linux实现中断的下半部主要有四种方式:</strong></p>
<ul>
<li><strong>软中断 SoftIRQ</strong></li>
<li><strong>TaskLet</strong></li>
<li><strong>工作队列Work queue</strong></li>
<li><strong>中断线程化</strong></li>
</ul>
<h2 id="8-软中断SoftIRQ"><a href="#8-软中断SoftIRQ" class="headerlink" title="8. 软中断SoftIRQ"></a>8. 软中断SoftIRQ</h2><p><strong>内核中提供了软中断相关的接口</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">open_softirq</span><span class="params">(<span class="type">int</span> nr, <span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action *))</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">raise_softirq_irqoff</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">raise_softirq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>软中断号的定义</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	HI_SOFTIRQ=<span class="number">0</span>,</span><br><span class="line">	TIMER_SOFTIRQ,</span><br><span class="line">	NET_TX_SOFTIRQ,</span><br><span class="line">	NET_RX_SOFTIRQ,</span><br><span class="line">	BLOCK_SOFTIRQ,</span><br><span class="line">	IRQ_POLL_SOFTIRQ,</span><br><span class="line">	TASKLET_SOFTIRQ,</span><br><span class="line">	SCHED_SOFTIRQ,</span><br><span class="line">	HRTIMER_SOFTIRQ,</span><br><span class="line">	RCU_SOFTIRQ,    <span class="comment">/* Preferable RCU should always be the last softirq */</span></span><br><span class="line"></span><br><span class="line">	NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//内核中提供了一些软中断, 这些软中断号越小代表着优先级越高</span></span><br></pre></td></tr></table></figure>

<h3 id="添加一个软中断"><a href="#添加一个软中断" class="headerlink" title="添加一个软中断"></a>添加一个软中断</h3><p><strong>添加自己的软中断只需要在上面的枚举中添加一行就行, 例如</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    HI_SOFTIRQ=<span class="number">0</span>,</span><br><span class="line">    ...</span><br><span class="line">    XXX_SOFTIRQ,</span><br><span class="line">    NR_SOFTIRQ</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用软中断"><a href="#使用软中断" class="headerlink" title="使用软中断"></a>使用软中断</h3><p><strong>由于Linux内核提供的接口仅供Linux内核的开发者使用, 所以驱动开发者是无法使用上述接口的, 但是可以通过EXPORT_SYMBOL宏将该接口导出</strong></p>
<p><strong>在Linux源码中添加以下代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/softirq.c</span></span><br><span class="line">EXPORT_SYMBOL(raise_softirq_irqoff);</span><br><span class="line">EXPORT_SYMBOL(raise_softirq);</span><br><span class="line">EXPORT_SYMBOL(open_softirq);</span><br></pre></td></tr></table></figure>

<h4 id="修改RTC驱动"><a href="#修改RTC驱动" class="headerlink" title="修改RTC驱动"></a>修改RTC驱动</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rtc_softirq_handler</span><span class="params">(<span class="keyword">struct</span> softirq_action* sa)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tick = regs-&gt;RTCDR;</span><br><span class="line">    current_time.hour = (tick % (<span class="number">24</span> * <span class="number">3600</span>)) / <span class="number">3600</span>;</span><br><span class="line">    current_time.min = (tick % <span class="number">3600</span>) / <span class="number">60</span>;</span><br><span class="line">    current_time.sec = tick % <span class="number">60</span>;</span><br><span class="line">    printk(<span class="string">&quot;%ld:%ld:%ld\n&quot;</span>, current_time.hour, current_time.min, current_time.sec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span>  <span class="title function_">rtc_alarm_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    set_rtc_alarm(regs);</span><br><span class="line">    raise_softirq(TASKLET_SOFTIRQ);</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">rtc_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">irqreturn_t</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    regs = (<span class="type">rtc_reg_t</span> *)ioremap(RTC_BASE, <span class="keyword">sizeof</span>(<span class="type">rtc_reg_t</span>)); </span><br><span class="line">    printk(<span class="string">&quot;rtc_init\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    set_rtc_alarm(regs);</span><br><span class="line">    ret = request_irq(<span class="number">39</span>, rtc_alarm_handler, <span class="number">0</span>, <span class="string">&quot;rtc0-test&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        printk(<span class="string">&quot;request_irq failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    open_softirq(TASKLET_SOFTIRQ, rtc_softirq_handler);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">rtc_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    free_irq(<span class="number">39</span>, <span class="literal">NULL</span>);</span><br><span class="line">    printk(<span class="string">&quot;Goodbye rtc module!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在上述代码中, 当中断到来时执行了rtc_alarm_handler, 该函数在执行过程中中断是关闭的, 其他中断无法打断, 在raise_softirq后注册的rtc_softirq_handler会执行, 此时的中断是开启的, 该函数可以被打断, 以此就达到了将上半部和下半部分开的目的</strong></p>
<h3 id="软中断实现"><a href="#软中断实现" class="headerlink" title="软中断实现"></a>软中断实现</h3><p><strong>在Linux内核中, 软中断的服务函数保存在一个结构体中</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">void</span>	(*action)(<span class="keyword">struct</span> softirq_action *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>和硬中断类似, Linux内核定义了一个softirq_action数组, 该数组保存了每个软中断号对应的软中断服务函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> <span class="title">softirq_vec</span>[<span class="title">NR_SOFTIRQS</span>];</span> <span class="comment">//NR_SOFTIRQS为软中断的数量</span></span><br></pre></td></tr></table></figure>

<p><strong>软中断的执行是从退出硬中断开始的, 在执行硬中断服务函数的函数前, 会有一个进入中断的操作, 在执行完毕后有退出中断的操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __handle_domain_irq(<span class="keyword">struct</span> irq_domain *domain, <span class="type">unsigned</span> <span class="type">int</span> hwirq,</span><br><span class="line">			<span class="type">bool</span> lookup, <span class="keyword">struct</span> pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">       </span><br><span class="line">	irq_enter();	<span class="comment">//进入中断</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//执行中断服务函数</span></span><br><span class="line"></span><br><span class="line">	irq_exit();		<span class="comment">//退出中断</span></span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>软中断就是从这个irq_exit()开始的</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/softirq.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	__irq_exit_rcu();	<span class="comment">//重点</span></span><br><span class="line">	rcu_irq_exit();</span><br><span class="line">	 <span class="comment">/* must be last! */</span></span><br><span class="line">	lockdep_hardirq_exit();</span><br><span class="line">&#125;</span><br><span class="line">				↓</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __irq_exit_rcu(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ARCH_IRQ_EXIT_IRQS_DISABLED</span></span><br><span class="line">	local_irq_disable();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	lockdep_assert_irqs_disabled();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	account_irq_exit_time(current);</span><br><span class="line">	preempt_count_sub(HARDIRQ_OFFSET);</span><br><span class="line">	<span class="keyword">if</span> (!in_interrupt() &amp;&amp; local_softirq_pending())</span><br><span class="line">		invoke_softirq();	<span class="comment">//重点, 判断当前是否以及退出硬中断以及是否触发了软中断</span></span><br><span class="line"></span><br><span class="line">	tick_irq_exit();</span><br><span class="line">&#125;</span><br><span class="line">			↓</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">invoke_softirq</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (ksoftirqd_running(local_softirq_pending()))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!force_irqthreads) &#123;</span><br><span class="line">		do_softirq_own_stack();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		wakeup_softirqd();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div align="center">↓</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///home/zhaixue/linux-5.10.4/include/linux/interrupt.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">do_softirq_own_stack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	__do_softirq();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center">↓</div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/softirq.c</span></span><br><span class="line">asmlinkage __visible <span class="type">void</span> __softirq_entry __do_softirq(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> end = jiffies + MAX_SOFTIRQ_TIME;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> old_flags = current-&gt;flags;</span><br><span class="line">	<span class="type">int</span> max_restart = MAX_SOFTIRQ_RESTART;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> *<span class="title">h</span>;</span></span><br><span class="line">	<span class="type">bool</span> in_hardirq;</span><br><span class="line">	__u32 pending;</span><br><span class="line">	<span class="type">int</span> softirq_bit;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Mask out PF_MEMALLOC as the current task context is borrowed for the</span></span><br><span class="line"><span class="comment">	 * softirq. A softirq handled, such as network RX, might set PF_MEMALLOC</span></span><br><span class="line"><span class="comment">	 * again if the socket is related to swapping.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	current-&gt;flags &amp;= ~PF_MEMALLOC;</span><br><span class="line"></span><br><span class="line">	pending = local_softirq_pending();</span><br><span class="line">	account_irq_enter_time(current);</span><br><span class="line"></span><br><span class="line">	__local_bh_disable_ip(_RET_IP_, SOFTIRQ_OFFSET);</span><br><span class="line">	in_hardirq = lockdep_softirq_start();</span><br><span class="line"></span><br><span class="line">restart:</span><br><span class="line">	<span class="comment">/* Reset the pending bitmask before enabling irqs */</span></span><br><span class="line">	set_softirq_pending(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	local_irq_enable();</span><br><span class="line"></span><br><span class="line">	h = softirq_vec;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((softirq_bit = ffs(pending))) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> vec_nr;</span><br><span class="line">		<span class="type">int</span> prev_count;</span><br><span class="line"></span><br><span class="line">		h += softirq_bit - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		vec_nr = h - softirq_vec;</span><br><span class="line">		prev_count = preempt_count();</span><br><span class="line"></span><br><span class="line">		kstat_incr_softirqs_this_cpu(vec_nr);</span><br><span class="line"></span><br><span class="line">		trace_softirq_entry(vec_nr);</span><br><span class="line">		h-&gt;action(h);	<span class="comment">//重点, 执行软中断</span></span><br><span class="line">		trace_softirq_exit(vec_nr);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(prev_count != preempt_count())) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;huh, entered softirq %u %s %p with preempt_count %08x, exited with %08x?\n&quot;</span>,</span><br><span class="line">			       vec_nr, softirq_to_name[vec_nr], h-&gt;action,</span><br><span class="line">			       prev_count, preempt_count());</span><br><span class="line">			preempt_count_set(prev_count);</span><br><span class="line">		&#125;</span><br><span class="line">		h++;</span><br><span class="line">		pending &gt;&gt;= softirq_bit;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (__this_cpu_read(ksoftirqd) == current)</span><br><span class="line">		rcu_softirq_qs();</span><br><span class="line">	local_irq_disable();</span><br><span class="line"></span><br><span class="line">	pending = local_softirq_pending();</span><br><span class="line">	<span class="keyword">if</span> (pending) &#123;</span><br><span class="line">		<span class="keyword">if</span> (time_before(jiffies, end) &amp;&amp; !need_resched() &amp;&amp;</span><br><span class="line">		    --max_restart)</span><br><span class="line">			<span class="keyword">goto</span> restart;</span><br><span class="line"></span><br><span class="line">		wakeup_softirqd();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lockdep_softirq_end(in_hardirq);</span><br><span class="line">	account_irq_exit_time(current);</span><br><span class="line">	__local_bh_enable(SOFTIRQ_OFFSET);</span><br><span class="line">	WARN_ON_ONCE(in_interrupt());</span><br><span class="line">	current_restore_flags(old_flags, PF_MEMALLOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="软中断运行机制"><a href="#软中断运行机制" class="headerlink" title="软中断运行机制"></a>软中断运行机制</h3><ul>
<li><strong>运行于中断退出后的某个时机</strong></li>
<li><strong>开启中断, 可以被其他中断打断, 不允许嵌套</strong></li>
<li><strong>当软中断执行次数过多或者执行时间大于2ms就会延后到线程中执行, 由系统进程ksoftirqd托管</strong></li>
</ul>
<h2 id="9-tasklet"><a href="#9-tasklet" class="headerlink" title="9. tasklet"></a>9. tasklet</h2><p><strong>tasklet是基于软中断实现的, 在软中断的枚举定义中就有一个TASKLET_SOFTIRQ, Linux内核提供了使用tasklet的api, 由于软中断仅供内核开发者使用, 所以驱动开发中一般使用tasklet进行中断的下半部操作</strong></p>
<h3 id="tasklet-接口"><a href="#tasklet-接口" class="headerlink" title="tasklet 接口"></a>tasklet 接口</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/linux/interrupt.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 		初始化一个task</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param t 	task结构体, 由用户定义</span></span><br><span class="line"><span class="comment"> * @param func 	回调函数的函数指针</span></span><br><span class="line"><span class="comment"> * @param data 	传递给回调函数的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tasklet_init</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t,</span></span><br><span class="line"><span class="params">			 <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>), <span class="type">unsigned</span> <span class="type">long</span> data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 		在TASKLET_SOFTIRQ的action回调中的task链表中将该task加入调度</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param t		task结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tasklet_schedule</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 		在HI_SOFTIRQ的action回调中的task链表中将该task加入调度, 比普通的tasklet的优先级要高</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param t 	task结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tasklet_hi_schedule</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 		在task链表中删除该task</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param t 	task结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tasklet_kill</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>将RTC驱动修改为使用tasklet的代码如下</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCDR;    <span class="comment">/* +0x00: data register */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCMR;    <span class="comment">/* +0x04: match register */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCLR;    <span class="comment">/* +0x08: load register */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCCR;    <span class="comment">/* +0x0C: control register */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCIMSC;  <span class="comment">/* +0x10: interrupt mask set and clear register*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCRIS;   <span class="comment">/* +0x14: raw interrupt status register*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCMIS;   <span class="comment">/* +0x18: masked interrupt status register */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCICR;   <span class="comment">/* +0x1C: interrupt clear register */</span></span><br><span class="line">&#125;<span class="type">rtc_reg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_time</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> year;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> month;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> day;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> hour;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> min;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_BASE 0x10017000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">rtc_reg_t</span> *regs = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_time</span> <span class="title">current_time</span>;</span></span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_rtc_alarm</span><span class="params">(<span class="type">rtc_reg_t</span> *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">    tmp = regs-&gt;RTCCR;    <span class="comment">/* write enable */</span></span><br><span class="line">    tmp = tmp &amp; <span class="number">0xFFFFFFFE</span>;</span><br><span class="line">    regs-&gt;RTCCR = tmp;</span><br><span class="line"></span><br><span class="line">    tmp = regs-&gt;RTCDR;    <span class="comment">/* get current time */</span></span><br><span class="line">    regs-&gt;RTCMR = tmp + <span class="number">1</span>;<span class="comment">/* set alarm time */</span></span><br><span class="line"></span><br><span class="line">    regs-&gt;RTCICR = <span class="number">1</span>;     <span class="comment">/* clear RTCINTR interrupt */</span> </span><br><span class="line">    regs-&gt;RTCIMSC = <span class="number">1</span>;    <span class="comment">/* set the mask */</span></span><br><span class="line"></span><br><span class="line">    tmp = regs-&gt;RTCCR;    <span class="comment">/* write disable */</span></span><br><span class="line">    tmp = tmp | <span class="number">0x1</span>;</span><br><span class="line">    regs-&gt;RTCCR = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rtc_tasklet_handler</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tick = regs-&gt;RTCDR;</span><br><span class="line">    current_time.hour = (tick % (<span class="number">24</span> * <span class="number">3600</span>)) / <span class="number">3600</span>;</span><br><span class="line">    current_time.min = (tick % <span class="number">3600</span>) / <span class="number">60</span>;</span><br><span class="line">    current_time.sec = tick % <span class="number">60</span>;</span><br><span class="line">    printk(<span class="string">&quot;%ld:%ld:%ld\n&quot;</span>, current_time.hour, current_time.min, current_time.sec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">rtc_task</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span>  <span class="title function_">rtc_alarm_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    set_rtc_alarm(regs);</span><br><span class="line">    tasklet_schedule(&amp;rtc_task);</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">rtc_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">irqreturn_t</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    regs = (<span class="type">rtc_reg_t</span> *)ioremap(RTC_BASE, <span class="keyword">sizeof</span>(<span class="type">rtc_reg_t</span>)); </span><br><span class="line">    printk(<span class="string">&quot;rtc_init\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    set_rtc_alarm(regs);</span><br><span class="line">    ret = request_irq(<span class="number">39</span>, rtc_alarm_handler, <span class="number">0</span>, <span class="string">&quot;rtc0-test&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        printk(<span class="string">&quot;request_irq failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tasklet_init(&amp;rtc_task, rtc_tasklet_handler, <span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">rtc_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    free_irq(<span class="number">39</span>, <span class="literal">NULL</span>);</span><br><span class="line">    tasklet_kill(&amp;rtc_task);</span><br><span class="line">    printk(<span class="string">&quot;Goodbye rtc module!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(rtc_init);</span><br><span class="line">module_exit(rtc_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="tasklet运行机制"><a href="#tasklet运行机制" class="headerlink" title="tasklet运行机制"></a>tasklet运行机制</h3><p><strong>在Linux内核中定义了两个链表, 用来存放普通的TASKLET_SOFTIRQ任务和HI_SOFTIRQ的任务</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/softirq.c</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_PER_CPU</span><span class="params">(<span class="keyword">struct</span> tasklet_head, tasklet_vec)</span>;</span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_PER_CPU</span><span class="params">(<span class="keyword">struct</span> tasklet_head, tasklet_hi_vec)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Linux内核中定义了TASKLET_SOFTIRQ和HI_SOFTIRQ这两个软中断的action, 在触发该软中断时会去遍历该task链表, 并取出其中的任务并执行</strong></p>
<p><strong>tasklet的运行机制:</strong></p>
<ul>
<li><strong>基于软中断</strong></li>
<li><strong>开启中断, 运行于中断上下文</strong></li>
<li><strong>当tasklet负载过重时, 会被转移到进程上下文中运行</strong></li>
</ul>
<h2 id="10-工作队列workqueue"><a href="#10-工作队列workqueue" class="headerlink" title="10.工作队列workqueue"></a>10.工作队列workqueue</h2><h3 id="workqueue-API介绍"><a href="#workqueue-API介绍" class="headerlink" title="workqueue API介绍"></a>workqueue API介绍</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个work</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_WORK(_work, _func);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 			将一个work添加进work队列中参与调度</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param work 		用户的work</span></span><br><span class="line"><span class="comment"> * @return true </span></span><br><span class="line"><span class="comment"> * @return false </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">schedule_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 			将一个work从work队列中取消</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param work 		用户的work</span></span><br><span class="line"><span class="comment"> * @return true </span></span><br><span class="line"><span class="comment"> * @return false </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">cancel_work_sync</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>中断下半部使用workqueue实现的rtc驱动</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCDR;    <span class="comment">/* +0x00: data register */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCMR;    <span class="comment">/* +0x04: match register */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCLR;    <span class="comment">/* +0x08: load register */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCCR;    <span class="comment">/* +0x0C: control register */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCIMSC;  <span class="comment">/* +0x10: interrupt mask set and clear register*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCRIS;   <span class="comment">/* +0x14: raw interrupt status register*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCMIS;   <span class="comment">/* +0x18: masked interrupt status register */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCICR;   <span class="comment">/* +0x1C: interrupt clear register */</span></span><br><span class="line">&#125;<span class="type">rtc_reg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_time</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> year;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> month;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> day;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> hour;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> min;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_BASE 0x10017000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">rtc_reg_t</span> *regs = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_time</span> <span class="title">current_time</span>;</span></span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_rtc_alarm</span><span class="params">(<span class="type">rtc_reg_t</span> *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">    tmp = regs-&gt;RTCCR;    <span class="comment">/* write enable */</span></span><br><span class="line">    tmp = tmp &amp; <span class="number">0xFFFFFFFE</span>;</span><br><span class="line">    regs-&gt;RTCCR = tmp;</span><br><span class="line"></span><br><span class="line">    tmp = regs-&gt;RTCDR;    <span class="comment">/* get current time */</span></span><br><span class="line">    regs-&gt;RTCMR = tmp + <span class="number">1</span>;<span class="comment">/* set alarm time */</span></span><br><span class="line"></span><br><span class="line">    regs-&gt;RTCICR = <span class="number">1</span>;     <span class="comment">/* clear RTCINTR interrupt */</span> </span><br><span class="line">    regs-&gt;RTCIMSC = <span class="number">1</span>;    <span class="comment">/* set the mask */</span></span><br><span class="line"></span><br><span class="line">    tmp = regs-&gt;RTCCR;    <span class="comment">/* write disable */</span></span><br><span class="line">    tmp = tmp | <span class="number">0x1</span>;</span><br><span class="line">    regs-&gt;RTCCR = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rtc_legacy_workqueue</span><span class="params">(<span class="keyword">struct</span> work_struct* work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tick = regs-&gt;RTCDR;</span><br><span class="line">    current_time.hour = (tick % (<span class="number">24</span> * <span class="number">3600</span>)) / <span class="number">3600</span>;</span><br><span class="line">    current_time.min = (tick % <span class="number">3600</span>) / <span class="number">60</span>;</span><br><span class="line">    current_time.sec = tick % <span class="number">60</span>;</span><br><span class="line">    printk(<span class="string">&quot;rtc workqueue work!&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;%ld:%ld:%ld\n&quot;</span>, current_time.hour, current_time.min, current_time.sec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">rtc_work</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span>  <span class="title function_">rtc_alarm_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    set_rtc_alarm(regs);</span><br><span class="line">    schedule_work(&amp;rtc_work);</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">rtc_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">irqreturn_t</span> ret = <span class="number">0</span>;</span><br><span class="line">    regs = (<span class="type">rtc_reg_t</span> *)ioremap(RTC_BASE, <span class="keyword">sizeof</span>(<span class="type">rtc_reg_t</span>)); </span><br><span class="line">    printk(<span class="string">&quot;rtc_init\n&quot;</span>);</span><br><span class="line">    set_rtc_alarm(regs);</span><br><span class="line">    ret = request_irq(<span class="number">39</span>, rtc_alarm_handler, <span class="number">0</span>, <span class="string">&quot;rtc0-test&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        printk(<span class="string">&quot;request_irq failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    INIT_WORK(&amp;rtc_work, rtc_legacy_workqueue);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">rtc_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    free_irq(<span class="number">39</span>, <span class="literal">NULL</span>);</span><br><span class="line">    cancel_work_sync(&amp;rtc_work);</span><br><span class="line">    printk(<span class="string">&quot;Goodbye rtc module!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(rtc_init);</span><br><span class="line">module_exit(rtc_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="延迟workqueue-API介绍"><a href="#延迟workqueue-API介绍" class="headerlink" title="延迟workqueue API介绍"></a>延迟workqueue API介绍</h3><p><strong>延迟工作队列是基于workqueue实现的, 可以用来实现一些需要延时执行的工作, 例如按键消抖</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个延迟work</span></span><br><span class="line"> INIT_DELAYED_WORK(_work, _func);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将一个work加入延迟工作队列中, 延迟一定时间后执行</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param dwork 	用户的work</span></span><br><span class="line"><span class="comment"> * @param delay 	延迟时间</span></span><br><span class="line"><span class="comment"> * @return true </span></span><br><span class="line"><span class="comment"> * @return false </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">schedule_delayed_work</span><span class="params">(<span class="keyword">struct</span> delayed_work *dwork,</span></span><br><span class="line"><span class="params">					 <span class="type">unsigned</span> <span class="type">long</span> delay)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 等待该work执行完毕</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param dwork 	用户的work</span></span><br><span class="line"><span class="comment"> * @return true </span></span><br><span class="line"><span class="comment"> * @return false </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">flush_delayed_work</span><span class="params">(<span class="keyword">struct</span> delayed_work *dwork)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 取消延时工作任务并等待它完成</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param dwork 	用户的work</span></span><br><span class="line"><span class="comment"> * @return true </span></span><br><span class="line"><span class="comment"> * @return false </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">cancel_delayed_work_sync</span><span class="params">(<span class="keyword">struct</span> delayed_work *dwork)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>使用延时工作队列实现中断下半部的rtc驱动</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCDR;    <span class="comment">/* +0x00: data register */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCMR;    <span class="comment">/* +0x04: match register */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCLR;    <span class="comment">/* +0x08: load register */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCCR;    <span class="comment">/* +0x0C: control register */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCIMSC;  <span class="comment">/* +0x10: interrupt mask set and clear register*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCRIS;   <span class="comment">/* +0x14: raw interrupt status register*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCMIS;   <span class="comment">/* +0x18: masked interrupt status register */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCICR;   <span class="comment">/* +0x1C: interrupt clear register */</span></span><br><span class="line">&#125;<span class="type">rtc_reg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_time</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> year;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> month;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> day;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> hour;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> min;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_BASE 0x10017000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">rtc_reg_t</span> *regs = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_time</span> <span class="title">current_time</span>;</span></span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_rtc_alarm</span><span class="params">(<span class="type">rtc_reg_t</span> *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">    tmp = regs-&gt;RTCCR;    <span class="comment">/* write enable */</span></span><br><span class="line">    tmp = tmp &amp; <span class="number">0xFFFFFFFE</span>;</span><br><span class="line">    regs-&gt;RTCCR = tmp;</span><br><span class="line"></span><br><span class="line">    tmp = regs-&gt;RTCDR;    <span class="comment">/* get current time */</span></span><br><span class="line">    regs-&gt;RTCMR = tmp + <span class="number">1</span>;<span class="comment">/* set alarm time */</span></span><br><span class="line"></span><br><span class="line">    regs-&gt;RTCICR = <span class="number">1</span>;     <span class="comment">/* clear RTCINTR interrupt */</span> </span><br><span class="line">    regs-&gt;RTCIMSC = <span class="number">1</span>;    <span class="comment">/* set the mask */</span></span><br><span class="line"></span><br><span class="line">    tmp = regs-&gt;RTCCR;    <span class="comment">/* write disable */</span></span><br><span class="line">    tmp = tmp | <span class="number">0x1</span>;</span><br><span class="line">    regs-&gt;RTCCR = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rtc_delayed_workqueue</span><span class="params">(<span class="keyword">struct</span> work_struct* work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tick = regs-&gt;RTCDR;</span><br><span class="line">    current_time.hour = (tick % (<span class="number">24</span> * <span class="number">3600</span>)) / <span class="number">3600</span>;</span><br><span class="line">    current_time.min = (tick % <span class="number">3600</span>) / <span class="number">60</span>;</span><br><span class="line">    current_time.sec = tick % <span class="number">60</span>;</span><br><span class="line">    printk(<span class="string">&quot;rtc workqueue work!&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;%ld:%ld:%ld\n&quot;</span>, current_time.hour, current_time.min, current_time.sec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> <span class="title">rtc_delay_work</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span>  <span class="title function_">rtc_alarm_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    set_rtc_alarm(regs);</span><br><span class="line">    schedule_delayed_work(&amp;rtc_delay_work, <span class="number">3</span>*HZ);</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">rtc_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">irqreturn_t</span> ret = <span class="number">0</span>;</span><br><span class="line">    regs = (<span class="type">rtc_reg_t</span> *)ioremap(RTC_BASE, <span class="keyword">sizeof</span>(<span class="type">rtc_reg_t</span>)); </span><br><span class="line">    printk(<span class="string">&quot;rtc_init\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    set_rtc_alarm(regs);</span><br><span class="line">    ret = request_irq(<span class="number">39</span>, rtc_alarm_handler, <span class="number">0</span>, <span class="string">&quot;rtc0-test&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        printk(<span class="string">&quot;request_irq failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    INIT_DELAYED_WORK(&amp;rtc_delay_work, rtc_delayed_workqueue);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">rtc_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    free_irq(<span class="number">39</span>, <span class="literal">NULL</span>);</span><br><span class="line">    flush_delayed_work(&amp;rtc_delay_work);</span><br><span class="line">    cancel_delayed_work_sync(&amp;rtc_delay_work);</span><br><span class="line">    printk(<span class="string">&quot;Goodbye rtc module!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(rtc_init);</span><br><span class="line">module_exit(rtc_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="workqueue的运行机制"><a href="#workqueue的运行机制" class="headerlink" title="workqueue的运行机制"></a>workqueue的运行机制</h3><ul>
<li><strong>运行于进程上下文</strong></li>
<li><strong>开启中断, 可以被抢占</strong></li>
</ul>
<h3 id="workqueue的弊端"><a href="#workqueue的弊端" class="headerlink" title="workqueue的弊端"></a>workqueue的弊端</h3><p><strong>在Linux中, 每个CPU都有一个工作队列线程, 这个线程维护了一个共享的workqueue, 叫做system_wq, 不同的驱动通过api向该workqueue中添加work, 多核CPU上, Linux则会使用均衡负载策略将work分配到不同的cpu上</strong></p>
<p><strong>由于工作队列运行在进程上下文, 所以驱动中的work是可以进行sleep的, 但是由于workqueue的执行是串行的, 所以, 当一个work在休眠时, 该workqueue上的其他work是无法执行的, 加入cpu的work过多, 势必会导致由于该work的休眠&#x2F;唤醒带来的时间浪费, 而拖慢整个系统的运行, 而且一个workqueue上的work是无法被转移到另一个cpu上的workqueue上运行的, 这就是普通workqueue的弊端</strong></p>
<h2 id="11-CMWQ-并发队列"><a href="#11-CMWQ-并发队列" class="headerlink" title="11. CMWQ(并发队列)"></a>11. CMWQ(并发队列)</h2><div align="center"><i>注: 部分内容引用自<a target="_blank" rel="noopener" href="https://www.likecs.com/show-190862.html" >https://www.likecs.com/show-190862.html</a></i></div>

<h3 id="WQ概述"><a href="#WQ概述" class="headerlink" title="WQ概述"></a>WQ概述</h3><p><strong>Workqueue(WQ)机制是Linux2.6以前内核中最常用的异步处理机制。Workqueue机制的主要概念包括：work用于描述放到队列里即将被执行的函数；worker表示一个独立的线程，用于执行异步上下文处理；workqueue用于存放work的队列。<br>当workqueue上有work条目时，worker线程被触发来执行work对应的函数。如果有多个work条目在队列，worker会按顺序处理所有work。</strong></p>
<p><strong>在最初的WQ实现中，多线程WQ（MTWQ）在每个CPU上都有一个worker线程，单线程WQ（STWQ）则总共只有一个worker线程。一个MTWQ的worker个数和CPU核数相同，多年来，MTWQ大量使用使得线程数量大量增加，甚至超过了某些系统对PID空间默认32K的限制。<br>尽管MTWQ浪费大量资源，但其提供的并发水平还是不能让人满意。并发的限制在STWQ和MTWQ上都存在，虽然MT相对来说不那么严重。MTWQ在每个CPU上提供了一个上下文执行环境，STWQ则在整个系统提供一个上下文执行环境。work任务需要竞争这些有限的执行环境资源，从而导致死锁等问题。</strong></p>
<h3 id="CMWQ概述"><a href="#CMWQ概述" class="headerlink" title="CMWQ概述"></a>CMWQ概述</h3><p><strong>并发和资源之间的紧张关系使得一些使用者不得不做出一些不必要的折中，比如libata的polling PIOs选择STWQ，这样就无法有两个polling PIOs同时进行处理。因为MTWQ并不能提供高并发能力，因此async和fscache不得不实现自己的线程池来提供高并发能力。<br>Concurrency Managed Workqueue (CMWQ)重新设计了WQ机制，并实现如下目标：</strong></p>
<ul>
<li><strong>1. 保持原workqueue API的兼容；</strong></li>
<li><strong>2. 使用per-CPU统一的worker池，为所有WQ共享使用并提供灵活的并发级别，同时不浪费不必要的资源；</strong></li>
<li><strong>3. 自动调整worker池和并发级别，让使用者不用关心这些细节。</strong></li>
</ul>
<h3 id="CMWQ设计思想"><a href="#CMWQ设计思想" class="headerlink" title="CMWQ设计思想"></a>CMWQ设计思想</h3><p><strong>一个work是一个简单的结构体，保存一个函数指针用于异步执行。任何驱动或者子系统想要一个函数被异步执行，都需要设置一个work指向该函数并将其放入workqueue队列。然后worker线程从队列上获取work并执行对应的函数，如果队列里没有work，则worker线程处于空闲状态。这些worker线程用线程池机制来管理。</strong></p>
<p><strong>CMWQ设计时将面向用户的workqueue机制和后台worker线程池管理机制进行了区分。后台的workqueue被称为GCWQ（推测可能是Global Concurrency WorkQueue），在每个CPU上存在一个GCWQ，用于处理该CPU上所有workqueue的work。每个GCWQ有两个线程池：一个用于普通work处理，另一个用于高优先级work处理。</strong></p>
<p><strong>内核子系统和驱动程序通过workqueue API创建和调度work，并可以通过设置flags来指定CPU核心、可重复性、并发限制，优先级等。当work放入workqueue时，通过队列参数和属性决定目标GCWQ和线程池，work最终放入对应线程池的共享worklist上。通过如果没有特别设定，work会被默认放入当前运行的CPU核上的GCWQ线程池的worklist上。</strong></p>
<p><strong>GCWQ的线程池在实现时同时考虑了并发能力和资源占用，仅可能占用最小的资源并提供足够的并发能力。每个CPU上绑定的线程池通过hook到CPU调度机制来实现并发管理。当worker被唤醒或者进入睡眠都会通知到线程池，线程池保持对当前可以运行的worker个数的跟踪。通常我们不期望一个work独占CPU和运行很多个CPU周期，因此维护刚好足够的并发以防止work处理的速度降低是最优的。当CPU上有一个或多个runnalbe的worker，线程池不会启动新的work任务。当上一个running的work转入睡眠，则立即调度一个新的worker。这样当有work在pending的时候，CPU一直保持干活的状态。这样来保证用最小的worker个数同时足够的执行带宽。</strong></p>
<p><strong>维持idle状态的worker只是消耗部分kthreads的内存，因此CMWQ在杀掉idle的worker之前一段时间让其活着。</strong></p>
<p><strong>unbound的WQ并不使用上述机制，而是用pseudo unbound CPU的线程池去尽快处理所有work。CMWQ的使用者来控制并发级别，并可以设置一个flag来忽略并发管理机制。</strong></p>
<p><strong>CMWQ通过创建更多的worker以及rescue-worker来保证任务按时处理。所有可能在内存回收的代码路径上执行的work必须放到特定的workqueue，该workqueue上有一个rescue-worker可以在内存压力下执行，这样避免在内存回收时出现死锁。</strong></p>
<h3 id="CMWQ-API介绍"><a href="#CMWQ-API介绍" class="headerlink" title="CMWQ API介绍"></a>CMWQ API介绍</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 用于分配一个WQ。原来的create_workqueue()系列接口已经弃用并计划删除</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param fmt 			该wq的名字</span></span><br><span class="line"><span class="comment"> * @param flags 		该wq的属性</span></span><br><span class="line"><span class="comment"> * @param max_active 	该wq可使用最多的线程数</span></span><br><span class="line"><span class="comment"> * @param ...</span></span><br><span class="line"><span class="comment"> * @return 				返回的wq指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> workqueue_struct *<span class="title function_">alloc_workqueue</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,</span></span><br><span class="line"><span class="params">					 <span class="type">unsigned</span> <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">					 <span class="type">int</span> max_active, ...)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 		将一个work加入到一个workqueue中开始调度</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param wq 	target wq</span></span><br><span class="line"><span class="comment"> * @param work 	target work</span></span><br><span class="line"><span class="comment"> * @return true </span></span><br><span class="line"><span class="comment"> * @return false </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">queue_work</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> work_struct *work)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>基于CMWQ的中断下半部实现的rtc驱动:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;linux/wait.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCDR;    <span class="comment">/* +0x00: data register */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCMR;    <span class="comment">/* +0x04: match register */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCLR;    <span class="comment">/* +0x08: load register */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCCR;    <span class="comment">/* +0x0C: control register */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCIMSC;  <span class="comment">/* +0x10: interrupt mask set and clear register*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCRIS;   <span class="comment">/* +0x14: raw interrupt status register*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCMIS;   <span class="comment">/* +0x18: masked interrupt status register */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCICR;   <span class="comment">/* +0x1C: interrupt clear register */</span></span><br><span class="line">&#125;<span class="type">rtc_reg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_time</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> year;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> month;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> day;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> hour;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> min;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_BASE 0x10017000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">rtc_reg_t</span> *regs = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_time</span> <span class="title">current_time</span>;</span></span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">rtc_work</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span>* <span class="title">m_workqueue</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_rtc_alarm</span><span class="params">(<span class="type">rtc_reg_t</span> *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">    tmp = regs-&gt;RTCCR;    <span class="comment">/* write enable */</span></span><br><span class="line">    tmp = tmp &amp; <span class="number">0xFFFFFFFE</span>;</span><br><span class="line">    regs-&gt;RTCCR = tmp;</span><br><span class="line"></span><br><span class="line">    tmp = regs-&gt;RTCDR;    <span class="comment">/* get current time */</span></span><br><span class="line">    regs-&gt;RTCMR = tmp + <span class="number">5</span>;<span class="comment">/* set alarm time */</span></span><br><span class="line"></span><br><span class="line">    regs-&gt;RTCICR = <span class="number">1</span>;     <span class="comment">/* clear RTCINTR interrupt */</span> </span><br><span class="line">    regs-&gt;RTCIMSC = <span class="number">1</span>;    <span class="comment">/* set the mask */</span></span><br><span class="line"></span><br><span class="line">    tmp = regs-&gt;RTCCR;    <span class="comment">/* write disable */</span></span><br><span class="line">    tmp = tmp | <span class="number">0x1</span>;</span><br><span class="line">    regs-&gt;RTCCR = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rtc_legacy_workqueue</span><span class="params">(<span class="keyword">struct</span> work_struct* work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tick = regs-&gt;RTCDR;</span><br><span class="line">    current_time.hour = (tick % (<span class="number">24</span> * <span class="number">3600</span>)) / <span class="number">3600</span>;</span><br><span class="line">    current_time.min = (tick % <span class="number">3600</span>) / <span class="number">60</span>;</span><br><span class="line">    current_time.sec = tick % <span class="number">60</span>;</span><br><span class="line">    printk(<span class="string">&quot;rtc cmwq work!&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;%ld:%ld:%ld\n&quot;</span>, current_time.hour, current_time.min, current_time.sec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span>  <span class="title function_">rtc_alarm_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    set_rtc_alarm(regs);</span><br><span class="line">    queue_work(m_workqueue, &amp;rtc_work);</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">rtc_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">irqreturn_t</span> ret = <span class="number">0</span>;</span><br><span class="line">    regs = (<span class="type">rtc_reg_t</span> *)ioremap(RTC_BASE, <span class="keyword">sizeof</span>(<span class="type">rtc_reg_t</span>)); </span><br><span class="line">    printk(<span class="string">&quot;rtc_init\n&quot;</span>);</span><br><span class="line">    set_rtc_alarm(regs);</span><br><span class="line">    ret = request_irq(<span class="number">39</span>, rtc_alarm_handler, <span class="number">0</span>, <span class="string">&quot;rtc0-test&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        printk(<span class="string">&quot;request_irq failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_workqueue = alloc_workqueue(<span class="string">&quot;rtc_wq&quot;</span>, WQ_MEM_RECLAIM, <span class="number">3</span>);</span><br><span class="line">    INIT_WORK(&amp;rtc_work, rtc_legacy_workqueue);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">rtc_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    free_irq(<span class="number">39</span>, <span class="literal">NULL</span>);</span><br><span class="line">    flush_workqueue(m_workqueue);</span><br><span class="line">    destroy_workqueue(m_workqueue);</span><br><span class="line">    printk(<span class="string">&quot;Goodbye rtc module!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(rtc_init);</span><br><span class="line">module_exit(rtc_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><em>参考: Documents&#x2F;core-api&#x2F;workqueue.rst</em></p>
<h2 id="12-中断线程化"><a href="#12-中断线程化" class="headerlink" title="12.中断线程化"></a>12.中断线程化</h2><p><strong>中断线程化与WQ不同的是, 中断线程化的下半部会创建一个内核线程直接参与调度, 当有中断发生时，响应中断后，会把中断处理函数当做一个线程与其他线程一样的处理，中断将作为内核线程运行，而且也可以被赋予不同的优先级，任务的优先级可能比中断线程的优先级高，这样做的目的就是保证高优先级的任务能被优先处理。</strong></p>
<p><strong>中断线程化后进一步压缩了上半部的工作量，上半部的工作仅仅需要完成 “快速检查”，譬如确保中断的确来自期望的设备；如果检查通过，它将对硬件中断完成确认并通知内核唤醒中断处理线程完成中断处理的下半部。</strong></p>
<p><strong>降低内核中的延迟只是中断线程化带来的好处之一，除此之外它还具备其他方面的优点。其中最突出的一点是：由于中断线程化后简化乃至避免了整个中断处理流程中 “硬中断” 和 “软中断” 两个阶段之间可能涉及的锁同步机制，从而降低了整体实现上的复杂性。中断处理线程化还有助于内核的调试。</strong></p>
<h3 id="中断线程化API"><a href="#中断线程化API" class="headerlink" title="中断线程化API"></a>中断线程化API</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param irq 			软中断号</span></span><br><span class="line"><span class="comment"> * @param handler 		中断处理函数</span></span><br><span class="line"><span class="comment"> * @param thread_fn 	中断线程化处理函数</span></span><br><span class="line"><span class="comment"> * @param irqflags 		中断属性</span></span><br><span class="line"><span class="comment"> * @param devname 		设备名</span></span><br><span class="line"><span class="comment"> * @param dev_id 		设备id</span></span><br><span class="line"><span class="comment"> * @return int </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">			 <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params">			 <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>使用中断线程化处理的rtc驱动:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;linux/irqreturn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;linux/stddef.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCDR;    <span class="comment">/* +0x00: data register */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCMR;    <span class="comment">/* +0x04: match register */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCLR;    <span class="comment">/* +0x08: load register */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCCR;    <span class="comment">/* +0x0C: control register */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCIMSC;  <span class="comment">/* +0x10: interrupt mask set and clear register*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCRIS;   <span class="comment">/* +0x14: raw interrupt status register*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCMIS;   <span class="comment">/* +0x18: masked interrupt status register */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  RTCICR;   <span class="comment">/* +0x1C: interrupt clear register */</span></span><br><span class="line">&#125;<span class="type">rtc_reg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_time</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> year;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> month;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> day;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> hour;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> min;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_BASE 0x10017000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">rtc_reg_t</span> *regs = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_time</span> <span class="title">current_time</span>;</span></span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_rtc_alarm</span><span class="params">(<span class="type">rtc_reg_t</span> *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">    tmp = regs-&gt;RTCCR;    <span class="comment">/* write enable */</span></span><br><span class="line">    tmp = tmp &amp; <span class="number">0xFFFFFFFE</span>;</span><br><span class="line">    regs-&gt;RTCCR = tmp;</span><br><span class="line"></span><br><span class="line">    tmp = regs-&gt;RTCDR;    <span class="comment">/* get current time */</span></span><br><span class="line">    regs-&gt;RTCMR = tmp + <span class="number">1</span>;<span class="comment">/* set alarm time */</span></span><br><span class="line"></span><br><span class="line">    regs-&gt;RTCICR = <span class="number">1</span>;     <span class="comment">/* clear RTCINTR interrupt */</span> </span><br><span class="line">    regs-&gt;RTCIMSC = <span class="number">1</span>;    <span class="comment">/* set the mask */</span></span><br><span class="line"></span><br><span class="line">    tmp = regs-&gt;RTCCR;    <span class="comment">/* write disable */</span></span><br><span class="line">    tmp = tmp | <span class="number">0x1</span>;</span><br><span class="line">    regs-&gt;RTCCR = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">rtc_thread_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tick = regs-&gt;RTCDR;</span><br><span class="line">    current_time.hour = (tick % (<span class="number">24</span> * <span class="number">3600</span>)) / <span class="number">3600</span>;</span><br><span class="line">    current_time.min = (tick % <span class="number">3600</span>) / <span class="number">60</span>;</span><br><span class="line">    current_time.sec = tick % <span class="number">60</span>;</span><br><span class="line">    printk(<span class="string">&quot;%ld:%ld:%ld\n&quot;</span>, current_time.hour, current_time.min, current_time.sec);</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span>  <span class="title function_">rtc_alarm_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    set_rtc_alarm(regs);</span><br><span class="line">    <span class="keyword">return</span> IRQ_WAKE_THREAD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">rtc_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">irqreturn_t</span> ret = <span class="number">0</span>;</span><br><span class="line">    regs = (<span class="type">rtc_reg_t</span> *)ioremap(RTC_BASE, <span class="keyword">sizeof</span>(<span class="type">rtc_reg_t</span>)); </span><br><span class="line">    printk(<span class="string">&quot;rtc_init\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    set_rtc_alarm(regs);</span><br><span class="line">    ret = request_threaded_irq(<span class="number">39</span>, rtc_alarm_handler, rtc_thread_handler, <span class="number">0</span>, <span class="string">&quot;rtc&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        printk(<span class="string">&quot;request_irq failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">rtc_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    free_irq(<span class="number">39</span>, <span class="literal">NULL</span>);</span><br><span class="line">    printk(<span class="string">&quot;Goodbye rtc module!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(rtc_init);</span><br><span class="line">module_exit(rtc_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/12/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F/" data-id="cll8647xs0000jom36qky0s7y" data-title="嵌入式Linux-中断子系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ARM/" rel="tag">ARM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E5%86%85%E6%A0%B8/" rel="tag">Linux内核</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD/" rel="tag">中断</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2023/08/12/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">嵌入式Linux-系统调用</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/">嵌入式开发</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ARM/" rel="tag">ARM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E5%86%85%E6%A0%B8/" rel="tag">Linux内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RTOS/" rel="tag">RTOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STM32/" rel="tag">STM32</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD/" rel="tag">中断</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ARM/" style="font-size: 20px;">ARM</a> <a href="/tags/Linux%E5%86%85%E6%A0%B8/" style="font-size: 20px;">Linux内核</a> <a href="/tags/RTOS/" style="font-size: 10px;">RTOS</a> <a href="/tags/STM32/" style="font-size: 10px;">STM32</a> <a href="/tags/%E4%B8%AD%E6%96%AD/" style="font-size: 10px;">中断</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/12/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F/">嵌入式Linux-中断子系统</a>
          </li>
        
          <li>
            <a href="/2023/08/12/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/">嵌入式Linux-系统调用</a>
          </li>
        
          <li>
            <a href="/2023/06/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E8%87%AA%E5%88%B6RTOS/">从零开始自制RTOS</a>
          </li>
        
          <li>
            <a href="/2023/06/09/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>