<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>从零开始自制RTOS | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="从零自制RTOS1. 什么是RTOS2. 需要的前置知识ARM汇编仅需要知道六个基础指令和基本的寄存器 基本寄存器R0-R3父函数在调用子函数前先将子函数入口参数存入 R0R3 寄存器中，若只有一个入口参数则使用 R0 寄存器传递，若有2个入口参数则使用 R0 和 R1 寄存器传递，以此类推。。当超过4个参数时，其余的入口参数则以此压入当前栈通过栈传递。子函数运行时，其将根据自身参数个数从 R0R">
<meta property="og:type" content="article">
<meta property="og:title" content="从零开始自制RTOS">
<meta property="og:url" content="http://example.com/2023/06/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E8%87%AA%E5%88%B6RTOS/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="从零自制RTOS1. 什么是RTOS2. 需要的前置知识ARM汇编仅需要知道六个基础指令和基本的寄存器 基本寄存器R0-R3父函数在调用子函数前先将子函数入口参数存入 R0R3 寄存器中，若只有一个入口参数则使用 R0 寄存器传递，若有2个入口参数则使用 R0 和 R1 寄存器传递，以此类推。。当超过4个参数时，其余的入口参数则以此压入当前栈通过栈传递。子函数运行时，其将根据自身参数个数从 R0R">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pic1.imgdb.cn/item/646dd1d20d2dde577702d605.png">
<meta property="og:image" content="https://pic.imgdb.cn/item/647cc00f1ddac507cca9f5f3.png">
<meta property="og:image" content="https://pic.imgdb.cn/item/6482c6ff1ddac507cc84350d.gif">
<meta property="article:published_time" content="2023-06-11T00:57:16.000Z">
<meta property="article:modified_time" content="2023-06-11T01:02:35.716Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="RTOS">
<meta property="article:tag" content="STM32">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic1.imgdb.cn/item/646dd1d20d2dde577702d605.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-从零开始自制RTOS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E8%87%AA%E5%88%B6RTOS/" class="article-date">
  <time class="dt-published" datetime="2023-06-11T00:57:16.000Z" itemprop="datePublished">2023-06-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/">嵌入式开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      从零开始自制RTOS
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="从零自制RTOS"><a href="#从零自制RTOS" class="headerlink" title="从零自制RTOS"></a>从零自制RTOS</h1><h2 id="1-什么是RTOS"><a href="#1-什么是RTOS" class="headerlink" title="1. 什么是RTOS"></a>1. 什么是RTOS</h2><h2 id="2-需要的前置知识"><a href="#2-需要的前置知识" class="headerlink" title="2. 需要的前置知识"></a>2. 需要的前置知识</h2><h3 id="ARM汇编"><a href="#ARM汇编" class="headerlink" title="ARM汇编"></a>ARM汇编</h3><p><strong>仅需要知道六个基础指令和基本的寄存器</strong></p>
<h4 id="基本寄存器"><a href="#基本寄存器" class="headerlink" title="基本寄存器"></a>基本寄存器</h4><h5 id="R0-R3"><a href="#R0-R3" class="headerlink" title="R0-R3"></a>R0-R3</h5><p><strong>父函数在调用子函数前先将子函数入口参数存入 R0<del>R3 寄存器中，若只有一个入口参数则使用 R0 寄存器传递，若有2个入口参数则使用 R0 和 R1 寄存器传递，以此类推。。当超过4个参数时，其余的入口参数则以此压入当前栈通过栈传递。子函数运行时，其将根据自身参数个数从 R0</del>R3 或者栈中读取入口参数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var_1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	var_1 = a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>该函数调用时,会将a和b放入R0-R3中，将该函数反汇编可以看到：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i.func1</span><br><span class="line">    func1</span><br><span class="line">    0x08000598:    1842        B.      ADDS     r2,r0,r1</span><br><span class="line">    0x0800059a:    4b01        .K      LDR      r3,[pc,#4] ; [0x80005a0] = 0x20000000</span><br><span class="line">    0x0800059c:    601a        .`      STR      r2,[r3,#0]</span><br><span class="line">    0x0800059e:    4770        pG      BX       lr</span><br></pre></td></tr></table></figure>

<p><strong>两个参数分别放入了R0和R1寄存器中，但是R0-R3一共只有四个寄存器，如果函数的参数大于四个，就需要用到栈了，通过栈将多出的参数保存：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2,<span class="type">int</span> v3,<span class="type">int</span> v4,<span class="type">int</span> v5,<span class="type">int</span> v6,<span class="type">int</span> v7,<span class="type">int</span> v8,<span class="type">int</span> v9,<span class="type">int</span> v10,<span class="type">int</span> v11,<span class="type">int</span> v12,<span class="type">int</span> v13,<span class="type">int</span> v14,<span class="type">int</span> v15,<span class="type">int</span> v16)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int</span> tmp;</span><br><span class="line">	tmp += v1;</span><br><span class="line">	tmp += v2;</span><br><span class="line">	tmp += v3;</span><br><span class="line">	tmp += v4;</span><br><span class="line">	tmp += v5;</span><br><span class="line">	tmp += v6;</span><br><span class="line">	tmp += v7;</span><br><span class="line">	tmp += v8;</span><br><span class="line">	tmp += v9;</span><br><span class="line">	tmp += v10;</span><br><span class="line">	tmp += v11;</span><br><span class="line">	tmp += v12;</span><br><span class="line">	tmp += v13;</span><br><span class="line">	tmp += v14;</span><br><span class="line">	tmp += v15;</span><br><span class="line">	tmp += v16;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>反汇编后查看函数如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">i.func</span><br><span class="line">    func</span><br><span class="line">    0x0800050c:    e92d4ff8    -..O    PUSH     &#123;r3-r11,lr&#125;</span><br><span class="line">    0x08000510:    4604        .F      MOV      r4,r0</span><br><span class="line">    0x08000512:    ad0a        ..      ADD      r5,sp,#0x28</span><br><span class="line">    0x08000514:    e89510e0    ....    LDM      r5,&#123;r5-r7,r12&#125;</span><br><span class="line">    0x08000518:    e9ddab10    ....    LDRD     r10,r11,[sp,#0x40]</span><br><span class="line">    0x0800051c:    e9dd890e    ....    LDRD     r8,r9,[sp,#0x38]</span><br><span class="line">    0x08000520:    9800        ..      LDR      r0,[sp,#0]</span><br><span class="line">    0x08000522:    4420         D      ADD      r0,r0,r4</span><br><span class="line">    ...</span><br><span class="line">    0x0800058e:    9000        ..      STR      r0,[sp,#0]</span><br><span class="line">    0x08000590:    9800        ..      LDR      r0,[sp,#0]</span><br><span class="line">    0x08000592:    e8bd8ff8    ....    POP      &#123;r3-r11,pc&#125;</span><br><span class="line">    0x08000596:    0000        ..      MOVS     r0,r0</span><br></pre></td></tr></table></figure>

<p><strong>可以看到，程序使用了SP寄存器（栈指针）来进行函数参数的读取</strong></p>
<h5 id="R4-R11-存放函数局部变量的寄存器"><a href="#R4-R11-存放函数局部变量的寄存器" class="headerlink" title="R4-R11 存放函数局部变量的寄存器"></a>R4-R11 存放函数局部变量的寄存器</h5><p><strong>普通的通用寄存器。AAPCS规定，发生函数调用时，父函数无需对这些寄存器进行备份处理，若子函数需要使用这些寄存器，则由子函数负责备份（需要使用哪个就备份哪个），以防止破坏父函数保存在 R4<del>R11 寄存器中的数据。子函数返回父函数前需先恢复 R4</del>R11 寄存器中的数值（使用了哪个就恢复哪个），恢复到父函数调用子函数这一时刻的数值，然后再返回到父函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c,d; <span class="comment">//放在R4-R11寄存器或者栈区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="R12-IP"><a href="#R12-IP" class="headerlink" title="R12(IP)"></a>R12(IP)</h5><p><strong>内部调用暂时寄存器 IP。它在过程链接胶合代码（例如，交互操作胶合代码）中用于此角色。在过程调用之间，可以将它用于任何用途。被调用函数在返回之前不必恢复 R12</strong></p>
<h5 id="R13-SP-栈指针"><a href="#R13-SP-栈指针" class="headerlink" title="R13(SP)栈指针"></a>R13(SP)栈指针</h5><p><strong>保护栈的当前指针，函数存储在栈中的数据就是通过这个寄存器来寻址的。函数返回时需要保证 SP 指向 调用 该函数时的栈地址。</strong></p>
<h5 id="R14-LR-链接寄存器"><a href="#R14-LR-链接寄存器" class="headerlink" title="R14(LR)链接寄存器"></a>R14(LR)链接寄存器</h5><p><strong>用来保存函数的返回地址。父函数调用子函数时，父函数会将调用子函数指令的下一条指令地址存入到 LR 寄存器中，当子函数返回时只需要跳转到 LR 寄存器里的地址就会返回父函数继续执行。父函数调用子函数将子函数返回地址存入 LR 寄存器前， LR 寄存器中保存的可能是父函数返回其上一级函数的地址或其他有用的数据，因此需要先备份 LR 寄存器然后才能调用子函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以一段代码为例</span></span><br><span class="line"><span class="comment">//main()中:</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> x = <span class="number">10</span>, y =<span class="number">20</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> reslut = <span class="number">0</span>;</span><br><span class="line">reslut = add(&amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line"><span class="comment">//add(int*, int*)中:</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int</span> tmp = *a;</span><br><span class="line">	tmp += *b;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main()反汇编:</span></span><br><span class="line">i.main</span><br><span class="line">main</span><br><span class="line">    ...</span><br><span class="line">	<span class="number">0x080006c4</span>:    <span class="number">200</span>a        .       MOVS     r0,#<span class="number">0xa</span>				;把<span class="number">10</span>保存到R0中, 等同于<span class="type">int</span> x = <span class="number">10</span></span><br><span class="line">    <span class="number">0x080006c6</span>:    <span class="number">900</span>e        ..      STR      r0,[sp,#<span class="number">0x38</span>]		;把R0保存到栈中</span><br><span class="line">    <span class="number">0x080006c8</span>:    <span class="number">2014</span>        .       MOVS     r0,#<span class="number">0x14</span>			;把<span class="number">20</span>保存到R0中, 等同于<span class="type">int</span> y = <span class="number">20</span></span><br><span class="line">    <span class="number">0x080006ca</span>:    <span class="number">900</span>d        ..      STR      r0,[sp,#<span class="number">0x34</span>]		;把R0保存到栈中</span><br><span class="line">    <span class="number">0x080006cc</span>:    <span class="number">2000</span>        .       MOVS     r0,#<span class="number">0</span>				;把<span class="number">0</span>保存到R0中, 等同于<span class="type">int</span> reslut = <span class="number">0</span></span><br><span class="line">    <span class="number">0x080006ce</span>:    <span class="number">900</span>c        ..      STR      r0,[sp,#<span class="number">0x30</span>]		;把R0保存到栈中	</span><br><span class="line">    <span class="number">0x080006d0</span>:    a90d        ..      ADD      r1,sp,#<span class="number">0x34</span>			;把sp指针+<span class="number">34</span>的值放到R1寄存器,相当于&amp;y</span><br><span class="line">    <span class="number">0x080006d2</span>:    a80e        ..      ADD      r0,sp,#<span class="number">0x38</span>			;把sp指针+<span class="number">38</span>的值放到R0寄存器,相当于&amp;x</span><br><span class="line">    <span class="number">0x080006d4</span>:    f7ffff0c    ....    BL       add ; <span class="number">0x80004f0</span>		;将下一条指令的地址<span class="number">0x080006d8</span>存到LR寄存																		 器,然后跳转到add函数</span><br><span class="line">    <span class="number">0x080006d8</span>:    <span class="number">900</span>c        ..      STR      r0,[sp,#<span class="number">0x30</span>]		;PC指向该条指令</span><br><span class="line">    <span class="number">0x080006da</span>:    <span class="number">980</span>e        ..      LDR      r0,[sp,#<span class="number">0x38</span>]</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">//add(int*, int*)反汇编:</span></span><br><span class="line">i.add</span><br><span class="line">add</span><br><span class="line">    <span class="number">0x080004f0</span>:    b518        ..      PUSH     &#123;r3,r4,lr&#125;			;该函数中使用了R3,R4,并需要返回,所以将																		 R3,R3,LR入栈</span><br><span class="line">    <span class="number">0x080004f2</span>:    <span class="number">4602</span>        .F      MOV      r2,r0				;函数内容自行理解</span><br><span class="line">    <span class="number">0x080004f4</span>:    <span class="number">6810</span>        .h      LDR      r0,[r2,#<span class="number">0</span>]</span><br><span class="line">    <span class="number">0x080004f6</span>:    <span class="number">9000</span>        ..      STR      r0,[sp,#<span class="number">0</span>]</span><br><span class="line">    <span class="number">0x080004f8</span>:    <span class="number">6808</span>        .h      LDR      r0,[r1,#<span class="number">0</span>]</span><br><span class="line">    <span class="number">0x080004fa</span>:    <span class="number">9</span>c00        ..      LDR      r4,[sp,#<span class="number">0</span>]</span><br><span class="line">    <span class="number">0x080004fc</span>:    <span class="number">4420</span>         D      ADD      r0,r0,r4</span><br><span class="line">    <span class="number">0x080004fe</span>:    <span class="number">9000</span>        ..      STR      r0,[sp,#<span class="number">0</span>]</span><br><span class="line">    <span class="number">0x08000500</span>:    <span class="number">6810</span>        .h      LDR      r0,[r2,#<span class="number">0</span>]</span><br><span class="line">    <span class="number">0x08000502</span>:    <span class="number">680</span>c        .h      LDR      r4,[r1,#<span class="number">0</span>]</span><br><span class="line">    <span class="number">0x08000504</span>:    <span class="number">1903</span>        ..      ADDS     r3,r0,r4</span><br><span class="line">    <span class="number">0x08000506</span>:    <span class="number">9800</span>        ..      LDR      r0,[sp,#<span class="number">0</span>]</span><br><span class="line">    <span class="number">0x08000508</span>:    bd18        ..      POP      &#123;r3,r4,pc&#125;			;当函数执行完成后,将R3,R4恢复至函数调用前,																	  并将PC寄存器指向LR存放的地址,即为main中调																		用add完成后下一条指令的地址<span class="number">0x080006d8</span></span><br></pre></td></tr></table></figure>



<h5 id="R15-PC-程序"><a href="#R15-PC-程序" class="headerlink" title="R15(PC) 程序"></a>R15(PC) 程序</h5><p><strong>正在执行的指令地址就存储在 PC 寄存器中，更改 PC 寄存器的数值就会执行这个数值所对应的地址中的指令</strong></p>
<h5 id="PSR-CPSR-SPSRs-程序状态寄存器"><a href="#PSR-CPSR-SPSRs-程序状态寄存器" class="headerlink" title="PSR(CPSR, SPSRs)程序状态寄存器"></a>PSR(CPSR, SPSRs)程序状态寄存器</h5><p><strong>ARM的PSR寄存器分为CPSR(当前程序状态寄存器)和SPSR(保存程序状态寄存器)，CPSR用来保存程序的各种状态，包括条件标志位，中断标志位，当前处理器模式控制以及其他状态和控制位，在所有模式下均可访问。每个异常模式都有一个SPSR寄存器，当异常来临时，将CPSR的值保存至SPSR，(USER模式和SYS模式均没有SPSR，因为它们不是异常模式)</strong></p>
<p><img src="https://pic1.imgdb.cn/item/646dd1d20d2dde577702d605.png" alt="PSR格式"></p>
<p><strong>PSR位的类型：</strong></p>
<ul>
<li><p>预留位：为将来的扩展预留</p>
</li>
<li><p>用户可写位：在任意模式下都可写，N，Z，C，V，Q，和GE[3:0]以及E位都是用户可写的。</p>
</li>
<li><p>特权模式位：在特权模式下可写，用户模式下写特权位没有效果，A，I，F，T和M[4:0]都是特权位。</p>
</li>
<li><p>执行状态位：在特权模式下可写，用户模式下写执行状态位没有效果，J和T位都是执行状态位，在ARM状态下一直为0</p>
</li>
<li><p>条件标志位<br>N，Z，C，V这四位被称为条件标志位，几乎所有指令都会测试CPSR中的条件标志位来决定指令是否执行。<br>条件标志位有两种方式修改：<br>1，执行比较指令：CMN，CMP，TEQ以及TST<br>2，执行一些其他的算数，逻辑或者移动指令，并且他们的目的寄存器不是R15。</p>
</li>
</ul>
<p><strong>各个标志位的含义：</strong></p>
<ul>
<li><p>N：设为指令结果的第31位，如果结果当作二进制补码表示的有符号整型，N&#x3D;1表示结果是负的；N&#x3D;0表示结果是非负的。</p>
</li>
<li><p>Z：指令结果是0的情况下设置为1，反之设为0。</p>
</li>
<li><p>C：C位的设置存在以下四种情况：</p>
<ul>
<li>对于加法，包括比较指令CMN，如果加法运算产生无符号溢出，C设为1，反之设为0。</li>
<li>对于减法，包括比较指令CMP，如果减法运算产生一个借位，C就设置为1，反之设为0。</li>
<li>对于包含移位操作的非加减运算，C设为移位器移出的最后一位。</li>
<li>对于其他的非加减运算，C通常保持不变。</li>
<li>这一位的设置存在以下两种情况：<ul>
<li>在两个二进制补码的有符号整形的加法和减法指令运算时，如果发生符号溢出，设置为1。</li>
<li>对于非加法和减法指令，V通常是不改变的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>以上这些标志位还可以通过以下的这些方式进行修改：</strong></p>
<ul>
<li>执行MSR指令，向CPSR或SPSR寄存器中写入新值。</li>
<li>执行目的寄存器是R15的MRC指令，该指令的目的是将些处理器产生的条件标志位传递到ARM处理器中。</li>
<li>执行LDM指令的某些变种指令，这些变种指令会复制SPSR的值到CPSR中。这种主要是用于异常返回的情况下。</li>
<li>在特权模式执行RFE指令可以从内存中向CPSR中加载新值。</li>
<li>执行目的寄存器是R15的算术逻辑指令的设置标志位的变种指令，它们也可以复制SPSR的值到CPSR中，用于异常返回。</li>
</ul>
<h4 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h4><h5 id="ADD-加指令"><a href="#ADD-加指令" class="headerlink" title="ADD 加指令"></a>ADD 加指令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD R0, R1, R2 ;R0 = R1 + R2</span><br><span class="line">ADD R0, R1, #1 ;R0 = R1 + 1</span><br></pre></td></tr></table></figure>

<h5 id="SUB-减指令"><a href="#SUB-减指令" class="headerlink" title="SUB 减指令"></a>SUB 减指令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SUB R0, R1, R2 ;R0 = R1 - R2</span><br><span class="line">SUB R0, R1, #1 ;R0 = R1 - 1</span><br></pre></td></tr></table></figure>

<h5 id="LDR-读内存指令"><a href="#LDR-读内存指令" class="headerlink" title="LDR 读内存指令"></a>LDR 读内存指令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR R0, [R1, #4] ;将R1的值加4作为地址，将该地址的数据取出来存放到R0</span><br></pre></td></tr></table></figure>

<h5 id="STR-写内存指令"><a href="#STR-写内存指令" class="headerlink" title="STR 写内存指令"></a>STR 写内存指令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STR R0, [R1, #8] ;将R0的值写入到R1+8这个地址的内存上去</span><br></pre></td></tr></table></figure>

<h5 id="CMP-比较指令"><a href="#CMP-比较指令" class="headerlink" title="CMP 比较指令"></a>CMP 比较指令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMP R0, R1 ;比较R0和R1的值保存到PSR寄存器上</span><br></pre></td></tr></table></figure>

<h5 id="B-跳转指令"><a href="#B-跳转指令" class="headerlink" title="B 跳转指令"></a>B 跳转指令</h5><p><strong>跳转指令分为好几种，包括B，BX，BEQ，BL， BLX等</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">B func ;最简单的跳转，无条件跳转到func函数地址去，从那里继续执行</span><br><span class="line"></span><br><span class="line">CMP R0, #1 </span><br><span class="line">BEQ func ;当CPSR的Z条件码置位后，跳转至func函数执行</span><br><span class="line"></span><br><span class="line">BL&#123;条件&#125; func ;将当前PC值保存至LR中，然后跳转至func函数执行，该指令用在需要返回的函数中</span><br><span class="line"></span><br><span class="line">BX&#123;条件&#125; func ;带状态切换的跳转，当最低为为1时，切换到Thumb指令执行，最低位为0时切换到ARM指令执行</span><br><span class="line"></span><br><span class="line">BLX func ;结合了BL和BX的特点</span><br></pre></td></tr></table></figure>

<h3 id="中断上下文保护"><a href="#中断上下文保护" class="headerlink" title="中断上下文保护"></a>中断上下文保护</h3><p><strong>通过对函数的反汇编分析,可以看到如果函数中用到了R4-R11寄存器,那么就必须在函数开始将修改的这些寄存器和LR寄存器提前PUSH入栈,对寄存器进行保护</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2,<span class="type">int</span> v3,<span class="type">int</span> v4,<span class="type">int</span> v5,<span class="type">int</span> v6,<span class="type">int</span> v7,<span class="type">int</span> v8,<span class="type">int</span> v9,<span class="type">int</span> v10,<span class="type">int</span> v11,<span class="type">int</span> v12,<span class="type">int</span> v13,<span class="type">int</span> v14,<span class="type">int</span> v15,<span class="type">int</span> v16)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数部分反汇编如下</span></span><br><span class="line">i.func</span><br><span class="line">func</span><br><span class="line">    <span class="number">0x08000516</span>:    e92d4ff8    -..O    PUSH     &#123;r3-r11,lr&#125;</span><br><span class="line">    <span class="number">0x0800051a</span>:    <span class="number">4604</span>        .F      MOV      r4,r0</span><br><span class="line">    <span class="number">0x0800051c</span>:    ad0a        ..      ADD      r5,sp,#<span class="number">0x28</span></span><br><span class="line">    <span class="number">0x0800051e</span>:    e89510e0    ....    LDM      r5,&#123;r5-r7,r12&#125;</span><br><span class="line">    <span class="number">0x08000522</span>:    e9ddab10    ....    LDRD     r10,r11,[sp,#<span class="number">0x40</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">send_addr</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> temp[<span class="number">12</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">sprintf</span>(temp, <span class="string">&quot;0x%p&quot;</span>,addr);</span><br><span class="line">	temp[<span class="number">10</span>] = <span class="string">&#x27;\r&#x27;</span>;</span><br><span class="line">	temp[<span class="number">11</span>] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	usart1_send_string(temp, <span class="number">12</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//部分反汇编如下</span></span><br><span class="line">i.send_addr</span><br><span class="line">send_addr</span><br><span class="line">    <span class="number">0x0800071c</span>:    b53e        &gt;.      PUSH     &#123;r1-r5,lr&#125;</span><br><span class="line">    <span class="number">0x0800071e</span>:    <span class="number">4604</span>        .F      MOV      r4,r0</span><br><span class="line">    <span class="number">0x08000720</span>:    <span class="number">2000</span>        .       MOVS     r0,#<span class="number">0</span></span><br><span class="line">    <span class="number">0x08000722</span>:    <span class="number">9000</span>        ..      STR      r0,[sp,#<span class="number">0</span>]</span><br><span class="line">    <span class="number">0x08000724</span>:    <span class="number">9001</span>        ..      STR      r0,[sp,#<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p><strong>以上几个例子中,当函数的局部变量过多时,不可避免会使用R4-R11这些寄存器用来保存临时变量,所以函数在调用前需要保存使用的寄存器到栈中,函数退出前将栈中的数据弹出,恢复R4-R11到调用前的状态</strong></p>
<p><strong>以上是普通函数调用时的寄存器保护流程,但是在中断里,程序并不知道什么时候中断会来临,并打断当前执行的程序,跳转到中断对应的服务函数中去</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下面这段代码为例</span></span><br><span class="line"><span class="comment">//main()中:</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> x = <span class="number">10</span>, y =<span class="number">20</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> reslut = <span class="number">0</span>;</span><br><span class="line">reslut = add(&amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line"><span class="comment">//main()反汇编:</span></span><br><span class="line">i.main</span><br><span class="line">main</span><br><span class="line">    ...</span><br><span class="line">	<span class="number">0x080006c4</span>:    <span class="number">200</span>a        .       MOVS     r0,#<span class="number">0xa</span>				;把<span class="number">10</span>保存到R0中, 等同于<span class="type">int</span> x = <span class="number">10</span></span><br><span class="line">    <span class="number">0x080006c6</span>:    <span class="number">900</span>e        ..      STR      r0,[sp,#<span class="number">0x38</span>]		;把R0保存到栈中</span><br><span class="line">    <span class="number">0x080006c8</span>:    <span class="number">2014</span>        .       MOVS     r0,#<span class="number">0x14</span>			;把<span class="number">20</span>保存到R0中, 等同于<span class="type">int</span> y = <span class="number">20</span></span><br><span class="line">    <span class="number">0x080006ca</span>:    <span class="number">900</span>d        ..      STR      r0,[sp,#<span class="number">0x34</span>]		;把R0保存到栈中</span><br><span class="line">    <span class="number">0x080006cc</span>:    <span class="number">2000</span>        .       MOVS     r0,#<span class="number">0</span>				;把<span class="number">0</span>保存到R0中, 等同于<span class="type">int</span> reslut = <span class="number">0</span></span><br><span class="line">    <span class="number">0x080006ce</span>:    <span class="number">900</span>c        ..      STR      r0,[sp,#<span class="number">0x30</span>]		;把R0保存到栈中	</span><br><span class="line">    <span class="number">0x080006d0</span>:    a90d        ..      ADD      r1,sp,#<span class="number">0x34</span>			;把sp指针+<span class="number">34</span>的值放到R1寄存器,相当于&amp;y</span><br><span class="line">    <span class="number">0x080006d2</span>:    a80e        ..      ADD      r0,sp,#<span class="number">0x38</span>			;把sp指针+<span class="number">38</span>的值放到R0寄存器,相当于&amp;x</span><br><span class="line">    <span class="number">0x080006d4</span>:    f7ffff0c    ....    BL       add ; <span class="number">0x80004f0</span>		;将下一条指令的地址<span class="number">0x080006d8</span>存到LR寄存																		 器,然后跳转到add函数</span><br><span class="line">    <span class="number">0x080006d8</span>:    <span class="number">900</span>c        ..      STR      r0,[sp,#<span class="number">0x30</span>]		;PC指向该条指令</span><br><span class="line">    <span class="number">0x080006da</span>:    <span class="number">980</span>e        ..      LDR      r0,[sp,#<span class="number">0x38</span>]</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">//当中断来临时,例如SVC_Handler(任何一个中断都可以)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SVC_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	usart1_send_string(<span class="string">&quot;svc fault comming\r\n&quot;</span>, <span class="number">19</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SVC_Handler反汇编如下</span></span><br><span class="line">i.SVC_Handler</span><br><span class="line">SVC_Handler</span><br><span class="line">    <span class="number">0x08000488</span>:    b510        ..      PUSH     &#123;r4,lr&#125;</span><br><span class="line">    <span class="number">0x0800048a</span>:    <span class="number">2113</span>        .!      MOVS     r1,#<span class="number">0x13</span></span><br><span class="line">    <span class="number">0x0800048c</span>:    a001        ..      ADR      r0,&#123;pc&#125;+<span class="number">8</span> ; <span class="number">0x8000494</span></span><br><span class="line">    <span class="number">0x0800048e</span>:    f000f9ad    ....    BL       usart1_send_string ; <span class="number">0x80007ec</span></span><br><span class="line">    <span class="number">0x08000492</span>:    bd10        ..      POP      &#123;r4,pc&#125;</span><br><span class="line"><span class="comment">//可以看到中断的反汇编和其他函数并没有什么不同,同样只保存了R4-R11,LR寄存器</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//当中断到来时, main中的函数可能还在执行下面的指令</span></span><br><span class="line">	<span class="number">0x080006c4</span>:    <span class="number">200</span>a        .       MOVS     r0,#<span class="number">0xa</span>				;把<span class="number">10</span>保存到R0中, 等同于<span class="type">int</span> x = <span class="number">10</span></span><br><span class="line">	<span class="number">0x080006c6</span>:    <span class="number">900</span>e        ..      STR      r0,[sp,#<span class="number">0x38</span>]		;把R0保存到栈中</span><br><span class="line">---&gt;<span class="number">0x080006c8</span>:    <span class="number">2014</span>        .       MOVS     r0,#<span class="number">0x14</span>			;把<span class="number">20</span>保存到R0中, 等同于<span class="type">int</span> y = <span class="number">20</span></span><br><span class="line">	<span class="number">0x080006ca</span>:    <span class="number">900</span>d        ..      STR      r0,[sp,#<span class="number">0x34</span>]		;把R0保存到栈中</span><br><span class="line">	<span class="number">0x080006cc</span>:    <span class="number">2000</span>        .       MOVS     r0,#<span class="number">0</span>				;把<span class="number">0</span>保存到R0中, 等同于<span class="type">int</span> reslut = <span class="number">0</span></span><br><span class="line">	<span class="number">0x080006ce</span>:    <span class="number">900</span>c        ..      STR      r0,[sp,#<span class="number">0x30</span>]		;把R0保存到栈中</span><br><span class="line">        </span><br><span class="line"><span class="comment">//此时的程序还在使用R0寄存器, 但是程序跳去执行了SVC_Handler函数,然而在中断函数中也用到了R0寄存器,同时在反汇编中没看到保护R0的操作,那么CPU是如何保证执行完中断后继续执行中断前的代码的?</span></span><br><span class="line"><span class="comment">//实际上, 在中断来临时,CPU会自动保存R0-R3,R12,LR,PC,xPSR寄存器, 中断执行完成后,CPU自动恢复这些寄存器</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;可以使用以下指令进行寄存器的保护</span><br><span class="line">STMFD SP!, &#123;R0-R3,LR,PC, PSR&#125; </span><br><span class="line">; 从PSR,PC, LR, R3-R0依次将寄存器存入栈中</span><br></pre></td></tr></table></figure>



<p><strong>也就是说, 中断的上下文保护是由两个部分完成的, 一部分由CPU自动完成保存&amp;恢复, 另一部分R4-R11由软件自动保存&amp;恢复, 示意图如下</strong></p>
<p><img src="https://pic.imgdb.cn/item/647cc00f1ddac507cca9f5f3.png" alt="image-20230605004837698"></p>
<h2 id="3-第一个自定义任务"><a href="#3-第一个自定义任务" class="headerlink" title="3. 第一个自定义任务"></a>3. 第一个自定义任务</h2><h3 id="0-任务的定义"><a href="#0-任务的定义" class="headerlink" title="0. 任务的定义"></a>0. 任务的定义</h3><p><strong>什么是任务? 可以这样理解,一个任务就像一个单独的程序,任务里面有一个while循环, 在循环里面不停地做某些工作,这个循环永远不会退出, 一个RTOS中同时运行着很多的任务, 根据不同的方案进行任务的切换</strong></p>
<p><strong>任务需要哪些东西?</strong></p>
<h4 id="任务栈"><a href="#任务栈" class="headerlink" title="任务栈"></a>任务栈</h4><p><strong>每一个任务都需要有一个任务栈, 由于任务在运行期间, 对于全局变量,代码段, 这些东西可以通过地址进行访问, 但是在函数中定义的局部变量, 却需要保存在栈中, 如果多个任务使用同一个栈, 就会导致上一个任务保存的栈帧被破坏, 从而无法恢复到上一个任务, 所以, 每一个任务都需要一个单独的任务栈</strong></p>
<h4 id="任务入口"><a href="#任务入口" class="headerlink" title="任务入口"></a>任务入口</h4><p><strong>任务需要从某个地址进入运行, 这个地址通常是用户自定义的C函数, 通过该地址, OS就能够跳转到该位置运行</strong></p>
<h4 id="任务优先级"><a href="#任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h4><p><strong>不同的任务优先级也不一样, 有些任务需要高实时性,有些任务只需要空闲时运行, 所以给任务制定优先级能够更好地完成工作</strong></p>
<p><strong>通过以上定义, 可以将一个任务以结构体定义出来, 代码如下:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*TASK_FUNCTION)</span><span class="params">(<span class="type">void</span>*)</span>;	<span class="comment">//任务入口函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">	None = <span class="number">0x0</span>,				<span class="comment">//无优先级</span></span><br><span class="line">	PriorityIDLE,			<span class="comment">//空闲优先级</span></span><br><span class="line">	PriorityNormal,			<span class="comment">//普通优先级</span></span><br><span class="line">	PriorityHigh,			<span class="comment">//高优先级</span></span><br><span class="line">	PriorityRealTime		<span class="comment">//实时优先级</span></span><br><span class="line">&#125;TASK_PRIORITY;				<span class="comment">//任务优先级, 数字越大任务的优先级也就越高</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	TASK_FUNCTION f;		<span class="comment">//任务入口函数</span></span><br><span class="line">	<span class="type">void</span>* param;			<span class="comment">//任务参数</span></span><br><span class="line">	TASK_PRIORITY priority; <span class="comment">//任务优先级</span></span><br><span class="line">	<span class="type">uint8_t</span> *stack_base; 	<span class="comment">//任务栈基地址</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *task_name;	<span class="comment">//任务名</span></span><br><span class="line">	<span class="type">uint32_t</span> stack_size;	<span class="comment">//任务栈大小</span></span><br><span class="line">	<span class="type">uint32_t</span> *stack_top;	<span class="comment">//任务栈顶</span></span><br><span class="line">	<span class="type">uint32_t</span> *cur_stack;	<span class="comment">//当前栈指针</span></span><br><span class="line">	<span class="type">uint8_t</span> isFirstRun;		<span class="comment">//是否第一次运行</span></span><br><span class="line">&#125;TASK_TCB;					<span class="comment">//Task Control Block任务控制块, 包含了一个任务的基本信息</span></span><br></pre></td></tr></table></figure>

<p><strong>除了单个的任务之外, 还需要一个优先队列来保存创建的任务, 根据优先级来决定调度器的调度策略, 优先队列的节点包装了TCB以及这个任务的状态信息等等</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">	TASK_DISABLED = <span class="number">0x0</span>,	<span class="comment">//禁止调度</span></span><br><span class="line">	TASK_READY = <span class="number">0x1</span>,		<span class="comment">//准备好调度</span></span><br><span class="line">	TASK_EXEC,				<span class="comment">//正在运行</span></span><br><span class="line">	TASK_TERM,				<span class="comment">//挂起</span></span><br><span class="line">	TASK_DELAY,				<span class="comment">//延时</span></span><br><span class="line">&#125;TASK_STATUS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TASK_NODE</span>&#123;</span></span><br><span class="line">	TASK_TCB task;			<span class="comment">//任务控制块</span></span><br><span class="line">	TASK_STATUS status;		<span class="comment">//任务状态</span></span><br><span class="line">	<span class="type">uint32_t</span> delay_tick;	<span class="comment">//延时的tick</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">TASK_NODE</span> *<span class="title">pre</span>;</span>	<span class="comment">//上一个任务节点 低优先级</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">TASK_NODE</span> *<span class="title">next</span>;</span>	<span class="comment">//下一个任务节点 高优先级</span></span><br><span class="line">&#125;TASK_NODE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	TASK_NODE tasks[MAX_TASK_COUNT];	<span class="comment">//所有的任务节点数组</span></span><br><span class="line">	<span class="type">uint32_t</span> size;						<span class="comment">//当前任务数量</span></span><br><span class="line">	TASK_NODE *highest_node;			<span class="comment">//最高优先级任务</span></span><br><span class="line">	TASK_NODE *lowest_node;				<span class="comment">//最低优先级任务</span></span><br><span class="line">&#125;TASK_LIST;</span><br></pre></td></tr></table></figure>

<p><strong>通过TASK_NODE结构体包装了一个TASK_TCB变量, 还有任务状态,任务延时等信息, 整个任务通过一个数组模拟实现了一个优先队列, 通过pre&#x2F;next指针指向低&#x2F;高优先级的节点, 以此获得一条从最低优先级到最高优先级的静态链表, 这样调度器可以直接获取优先级最高的任务</strong></p>
<h3 id="1-创建任务"><a href="#1-创建任务" class="headerlink" title="1. 创建任务"></a>1. 创建任务</h3><p><strong>创建任务即在优先队列中添加一个TASK_NODE, 并根据优先级关系更新最高和最低优先级指针, 具体代码如下</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> TASK_TCB* <span class="title function_">list_add_task</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *task_name, TASK_FUNCTION func, <span class="type">void</span>* param, TASK_PRIORITY priority, <span class="type">uint8_t</span> *<span class="built_in">stack</span>, <span class="type">uint32_t</span> stack_size)</span></span><br><span class="line">&#123;</span><br><span class="line">	TASK_TCB *tcb = <span class="literal">NULL</span>;</span><br><span class="line">	TASK_NODE *node = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (os_task_list.size &gt;= MAX_TASK_COUNT) &#123;</span><br><span class="line">		<span class="keyword">return</span> tcb;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (os_task_list.size == <span class="number">0</span>) &#123;</span><br><span class="line">		task_tcb_init(&amp;os_task_list.tasks[os_task_list.size].task, task_name, func, param, priority, <span class="built_in">stack</span>, stack_size);</span><br><span class="line">		tcb = &amp;os_task_list.tasks[os_task_list.size].task;</span><br><span class="line">		os_task_list.highest_node = &amp;os_task_list.tasks[os_task_list.size];</span><br><span class="line">		os_task_list.lowest_node = &amp;os_task_list.tasks[os_task_list.size];</span><br><span class="line">		os_task_list.tasks[os_task_list.size].next = <span class="literal">NULL</span>;</span><br><span class="line">		os_task_list.tasks[os_task_list.size].pre = <span class="literal">NULL</span>;</span><br><span class="line">		node = &amp;os_task_list.tasks[os_task_list.size];</span><br><span class="line">		os_task_list.size ++;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		task_tcb_init(&amp;os_task_list.tasks[os_task_list.size].task, task_name, func, param, priority, <span class="built_in">stack</span>, stack_size);</span><br><span class="line">		tcb = &amp;os_task_list.tasks[os_task_list.size].task;</span><br><span class="line">		node = &amp;os_task_list.tasks[os_task_list.size];</span><br><span class="line">		os_task_list.size ++;</span><br><span class="line">		<span class="keyword">if</span> (os_task_list.highest_node == os_task_list.lowest_node) &#123;</span><br><span class="line">			<span class="keyword">if</span> (priority &gt; os_task_list.highest_node-&gt;task.priority) &#123;</span><br><span class="line">				os_task_list.lowest_node-&gt;next = node;</span><br><span class="line">				os_task_list.highest_node = node;</span><br><span class="line">				node-&gt;pre = os_task_list.lowest_node;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				os_task_list.highest_node-&gt;pre = node;</span><br><span class="line">				os_task_list.lowest_node = node;</span><br><span class="line">				node-&gt;next = os_task_list.highest_node;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (node-&gt;task.priority &lt;= os_task_list.lowest_node-&gt;task.priority) &#123;</span><br><span class="line">				os_task_list.lowest_node-&gt;pre = node;</span><br><span class="line">				node-&gt;next = os_task_list.lowest_node;</span><br><span class="line">				node-&gt;pre = <span class="literal">NULL</span>;</span><br><span class="line">				os_task_list.lowest_node = node;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;task.priority &gt;= os_task_list.highest_node-&gt;task.priority) &#123;</span><br><span class="line">				os_task_list.highest_node-&gt;next = node;</span><br><span class="line">				node-&gt;pre = os_task_list.highest_node;</span><br><span class="line">				node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">				os_task_list.highest_node = node;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				TASK_NODE *tmp = os_task_list.lowest_node;</span><br><span class="line">				<span class="keyword">while</span> (tmp-&gt;next-&gt;task.priority &lt;= node-&gt;task.priority) &#123;</span><br><span class="line">					tmp = tmp-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">				node-&gt;next = tmp-&gt;next;</span><br><span class="line">				tmp-&gt;next-&gt;pre = node;</span><br><span class="line">				tmp-&gt;next = node;</span><br><span class="line">				node-&gt;pre = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	node-&gt;status = TASK_READY;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 第一次进入函数没有编译器和cpu帮助保存恢复寄存器,所以需要伪造现场 */</span></span><br><span class="line">	<span class="type">int</span> *stack_top = (<span class="type">int</span> *)(<span class="built_in">stack</span> + stack_size);</span><br><span class="line">	tcb-&gt;stack_top = stack_top;</span><br><span class="line">	stack_top -= <span class="number">16</span>; <span class="comment">//需要保存16个寄存器 PSR, PC, LR, R12, R3, R2, R1, R0, R11, R10, R9, R8, R7, R6, R5, R4</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*R4-R11*/</span></span><br><span class="line">	stack_top[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//R4</span></span><br><span class="line">	stack_top[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//R5</span></span><br><span class="line">	stack_top[<span class="number">2</span>] = <span class="number">0</span>; <span class="comment">//R6</span></span><br><span class="line">	stack_top[<span class="number">3</span>] = <span class="number">0</span>; <span class="comment">//R7</span></span><br><span class="line">	stack_top[<span class="number">4</span>] = <span class="number">0</span>; <span class="comment">//R8</span></span><br><span class="line">	stack_top[<span class="number">5</span>] = <span class="number">0</span>; <span class="comment">//R9</span></span><br><span class="line">	stack_top[<span class="number">6</span>] = <span class="number">0</span>; <span class="comment">//R10</span></span><br><span class="line">	stack_top[<span class="number">7</span>] = <span class="number">0</span>; <span class="comment">//R11</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*R0-R3*/</span></span><br><span class="line">	stack_top[<span class="number">8</span>] = (<span class="type">int</span>)param; <span class="comment">//R0 函数参数</span></span><br><span class="line">	stack_top[<span class="number">9</span>] = <span class="number">0</span>; <span class="comment">//R1</span></span><br><span class="line">	stack_top[<span class="number">10</span>] = <span class="number">0</span>; <span class="comment">//R2</span></span><br><span class="line">	stack_top[<span class="number">11</span>] = <span class="number">0</span>; <span class="comment">//R3</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*R12, LR, PC, PSR*/</span></span><br><span class="line">	stack_top[<span class="number">12</span>] = <span class="number">0</span>; <span class="comment">//R12</span></span><br><span class="line">	stack_top[<span class="number">13</span>] = <span class="number">0</span>; <span class="comment">//LR 没有返回地址,所以设置为0</span></span><br><span class="line">	stack_top[<span class="number">14</span>] = (<span class="type">int</span>)func; <span class="comment">//PC 设为函数入口地址</span></span><br><span class="line">	<span class="comment">// stack_top[15] = 0x01000000; //PSR</span></span><br><span class="line">	stack_top[<span class="number">15</span>] = (<span class="number">1</span> &lt;&lt; <span class="number">24</span>); <span class="comment">//PSR 将Thumb位设置为1,使用Thumb指令集</span></span><br><span class="line"></span><br><span class="line">	tcb-&gt;cur_stack = (<span class="type">uint32_t</span>*)stack_top;	<span class="comment">//保存当前栈指针</span></span><br><span class="line">	tcb-&gt;isFirstRun = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> tcb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">task_tcb_init</span><span class="params">(TASK_TCB* tcb, <span class="type">const</span> <span class="type">char</span> *task_name, TASK_FUNCTION func, <span class="type">void</span>* param, TASK_PRIORITY priority, <span class="type">uint8_t</span> *<span class="built_in">stack</span>, <span class="type">uint32_t</span> stack_size)</span></span><br><span class="line">&#123;</span><br><span class="line">	tcb-&gt;task_name = task_name;</span><br><span class="line">	tcb-&gt;f = func;</span><br><span class="line">	tcb-&gt;param = param;</span><br><span class="line">	tcb-&gt;priority = priority;</span><br><span class="line">	tcb-&gt;stack_base = <span class="built_in">stack</span>;</span><br><span class="line">	tcb-&gt;stack_size = stack_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TASK_TCB* <span class="title function_">create_task</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *task_name, TASK_FUNCTION func, <span class="type">void</span>* param, TASK_PRIORITY priority, <span class="type">uint8_t</span> *<span class="built_in">stack</span>, <span class="type">uint32_t</span> stack_size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> list_add_task(task_name, func, param, priority, <span class="built_in">stack</span>, stack_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>该函数主要分为两部分, 一部分是优先队列的插入过程, 一部分是任务栈的伪造现场</strong></p>
<p><strong>队列的插入不过多赘述, 读者自行学习数据结构, 主要的部分是伪造现场</strong></p>
<p><strong>在前面提到, 一个中断来临时现场的保护分为两个部分, CPU自动保存的8个寄存器以及软件保存的R4-R11寄存器, 由于任务的启动和切换是由中断函数中的调度器完成的, 所以任务的初始化需要将该任务的栈伪造成中断来临后进行现场保护的假象</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 第一次进入函数没有编译器和cpu帮助保存恢复寄存器,所以需要伪造现场 */</span></span><br><span class="line">	<span class="type">int</span> *stack_top = (<span class="type">int</span> *)(<span class="built_in">stack</span> + stack_size);	<span class="comment">//获得栈顶指针</span></span><br><span class="line">	tcb-&gt;stack_top = stack_top;	</span><br><span class="line">	stack_top -= <span class="number">16</span>; <span class="comment">//需要保存16个寄存器,栈顶指针减16x4=64字节位置 PSR, PC, LR, R12, R3, R2, R1, R0, R11, R10, R9, R8, R7, R6, R5, R4</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*R4-R11*/</span></span><br><span class="line">	stack_top[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//R4</span></span><br><span class="line">	stack_top[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//R5</span></span><br><span class="line">	stack_top[<span class="number">2</span>] = <span class="number">0</span>; <span class="comment">//R6</span></span><br><span class="line">	stack_top[<span class="number">3</span>] = <span class="number">0</span>; <span class="comment">//R7</span></span><br><span class="line">	stack_top[<span class="number">4</span>] = <span class="number">0</span>; <span class="comment">//R8</span></span><br><span class="line">	stack_top[<span class="number">5</span>] = <span class="number">0</span>; <span class="comment">//R9</span></span><br><span class="line">	stack_top[<span class="number">6</span>] = <span class="number">0</span>; <span class="comment">//R10</span></span><br><span class="line">	stack_top[<span class="number">7</span>] = <span class="number">0</span>; <span class="comment">//R11</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*R0-R3*/</span></span><br><span class="line">	stack_top[<span class="number">8</span>] = (<span class="type">int</span>)param; <span class="comment">//R0 函数参数</span></span><br><span class="line">	stack_top[<span class="number">9</span>] = <span class="number">0</span>; <span class="comment">//R1</span></span><br><span class="line">	stack_top[<span class="number">10</span>] = <span class="number">0</span>; <span class="comment">//R2</span></span><br><span class="line">	stack_top[<span class="number">11</span>] = <span class="number">0</span>; <span class="comment">//R3</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*R12, LR, PC, PSR*/</span></span><br><span class="line">	stack_top[<span class="number">12</span>] = <span class="number">0</span>; <span class="comment">//R12</span></span><br><span class="line">	stack_top[<span class="number">13</span>] = <span class="number">0</span>; <span class="comment">//LR 没有返回地址,所以设置为0</span></span><br><span class="line">	stack_top[<span class="number">14</span>] = (<span class="type">int</span>)func; <span class="comment">//PC 设为函数入口地址</span></span><br><span class="line">	<span class="comment">// stack_top[15] = 0x01000000; //PSR</span></span><br><span class="line">	stack_top[<span class="number">15</span>] = (<span class="number">1</span> &lt;&lt; <span class="number">24</span>); <span class="comment">//PSR 将Thumb位设置为1,使用Thumb指令集</span></span><br><span class="line"></span><br><span class="line">	tcb-&gt;cur_stack = (<span class="type">uint32_t</span>*)stack_top;	<span class="comment">//保存当前栈指针</span></span><br></pre></td></tr></table></figure>

<p><strong>在main函数中, 调用create_task函数, 就可以添加一个任务</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">static</span> __attribute__((__aligned(<span class="number">4</span>))) <span class="type">uint8_t</span> task1_stack[<span class="number">512</span>]; <span class="comment">//任务栈, 栈需要4字节对齐, 使用__aligned(4)修饰</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//任务1函数入口</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">30</span>] = <span class="string">&quot;this is task1 num:   \r\n&quot;</span>;</span><br><span class="line">	<span class="type">uint8_t</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> tmp_var = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//do something</span></span><br><span class="line">		buffer[<span class="number">19</span>] = (<span class="type">char</span>)(tmp_var / <span class="number">100</span> + <span class="number">48</span>);</span><br><span class="line">		buffer[<span class="number">20</span>] = (<span class="type">char</span>)((tmp_var % <span class="number">100</span>) / <span class="number">10</span> + <span class="number">48</span>);</span><br><span class="line">		buffer[<span class="number">21</span>] = (<span class="type">char</span>)(tmp_var % <span class="number">10</span> + <span class="number">48</span>);</span><br><span class="line">		usart1_send_string(buffer, <span class="number">23</span>);</span><br><span class="line">		flag = ! flag;</span><br><span class="line">		tmp_var++;</span><br><span class="line">		<span class="keyword">if</span> (tmp_var &gt; <span class="number">100</span>) &#123;</span><br><span class="line">			tmp_var = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		task_delay(<span class="number">1</span>);</span><br><span class="line">		task1_usage = stack_usage();</span><br><span class="line">		delay(<span class="number">1000000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mymain</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	create_task(<span class="string">&quot;task1&quot;</span>, task1, <span class="string">&quot;task1&quot;</span>, PriorityNormal, (<span class="type">uint8_t</span>*)task1_stack, <span class="number">512</span>);</span><br><span class="line"></span><br><span class="line">	os_start_schedule();	<span class="comment">//开启调度</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-启动任务"><a href="#2-启动任务" class="headerlink" title="2. 启动任务"></a>2. 启动任务</h3><p><strong>在本项目中, 任务的调度依赖系统定时器中断, 通过实现Systick_Handler中断函数, 每隔1s进行一次调度, 由于任务的切换涉及到栈的切换, 为了能够在中断来后对当前栈进行保护, 所以使用汇编函数将Systick_Handler进行包装, 具体代码如下</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">				EXPORT	__Vectors</span><br><span class="line">				IMPORT	HardFault_Handler</span><br><span class="line">				IMPORT	UsageFault_Handler</span><br><span class="line">				IMPORT	SVC_Handler</span><br><span class="line">				IMPORT	SysTick_Handler</span><br><span class="line">				EXPORT 	SysTick_Handler_asm</span><br><span class="line">				EXPORT	UsageFault_Handler_asm</span><br><span class="line">; 中断向量表</span><br><span class="line">__Vectors		DCD		0</span><br><span class="line">				DCD		Reset_Handler				; Reset Handler</span><br><span class="line">				DCD     0                ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler        	; Hard Fault Handler</span><br><span class="line">                DCD     0          ; MPU Fault Handler</span><br><span class="line">                DCD     0           ; Bus Fault Handler</span><br><span class="line">                DCD     UsageFault_Handler_asm         	; Usage Fault Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     SVC_Handler                ; SVCall Handler</span><br><span class="line">                DCD     0           ; Debug Monitor Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0             ; PendSV Handler</span><br><span class="line">                DCD     SysTick_Handler_asm            ; SysTick Handler</span><br><span class="line"></span><br><span class="line">; 系统定时器的中断服务函数</span><br><span class="line">SysTick_Handler_asm PROC</span><br><span class="line">				BL 		SysTick_Handler		;跳转到SysTick_Handler</span><br><span class="line">				ENDP</span><br></pre></td></tr></table></figure>

<p><strong>在.c中定义了SysTick_Handler函数, 参数如下:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	SCB_Type * SCB = (SCB_Type *)SCB_BASE_ADDR;</span><br><span class="line">	<span class="comment">/* clear exception status */</span></span><br><span class="line">	SCB-&gt;ICSR |= SCB_ICSR_PENDSTCLR_Msk;		<span class="comment">//清除系统中断标志位, 防止一直进入中断</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//os调度</span></span><br><span class="line">	os_schedule();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在SysTick_Handler中调用了os的调度函数, 该函数用来进行任务的切换</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">THREAD_LOCAL TASK_NODE* cur_task = <span class="literal">NULL</span>; 	<span class="comment">//当前任务的控制块</span></span><br><span class="line">TASK_NODE *idle_task = <span class="literal">NULL</span>;				<span class="comment">//空闲任务的控制块, 该任务由os创建, </span></span><br><span class="line">TASK_NODE *delay_node = <span class="literal">NULL</span>, *init_node = <span class="literal">NULL</span>, *next_node = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">os_schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断os是否启动</span></span><br><span class="line">	<span class="keyword">if</span> (is_started()) &#123;</span><br><span class="line">		<span class="comment">//遍历任务链表, 将有延时的任务的延时时间减1</span></span><br><span class="line">		delay_node = os_task_list.highest_node;</span><br><span class="line">		<span class="keyword">while</span> (delay_node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (delay_node-&gt;status == TASK_DELAY) &#123;</span><br><span class="line">				delay_node-&gt;delay_tick --;</span><br><span class="line">				<span class="keyword">if</span> (delay_node-&gt;delay_tick == <span class="number">0</span>) &#123;</span><br><span class="line">					delay_node-&gt;status = TASK_READY;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			delay_node = delay_node-&gt;pre;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//有两个可能, 系统没有开始调度,cur_task为NULL, 系统已经开始调度,cur_task不为NULL</span></span><br><span class="line">		<span class="keyword">if</span> (cur_task == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="comment">//系统第一次开始调度, 从最高优先级的任务开始调度</span></span><br><span class="line">			init_node = os_task_list.highest_node;</span><br><span class="line">			<span class="comment">//找到最高优先级且状态为TASK_READY的任务</span></span><br><span class="line">			<span class="keyword">while</span>(init_node != <span class="literal">NULL</span> &amp;&amp; init_node-&gt;status != TASK_READY) &#123;</span><br><span class="line">				init_node = init_node-&gt;pre;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (init_node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				init_node-&gt;status = TASK_EXEC;</span><br><span class="line">				cur_task = init_node;</span><br><span class="line">				<span class="comment">//由于系统第一次调度,所以可以直接从函数入口地址开始运行</span></span><br><span class="line">				usart1_send_string(<span class="string">&quot;os_start_task\r\n&quot;</span>, <span class="number">15</span>);</span><br><span class="line">				cur_task-&gt;task.isFirstRun = <span class="number">0</span>;</span><br><span class="line">				start_task((<span class="type">int</span>)cur_task-&gt;task.cur_stack, <span class="number">0xFFFFFFF9</span>);	<span class="comment">//启动任务</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//系统不是第一次开始调度, 需要找到下一个调度任务</span></span><br><span class="line">			next_node = os_task_list.highest_node;</span><br><span class="line">			<span class="comment">//找到最高优先级且状态为TASK_READY的任务</span></span><br><span class="line">			<span class="keyword">while</span>(next_node != <span class="literal">NULL</span> &amp;&amp; next_node-&gt;status != TASK_READY) &#123;</span><br><span class="line">				next_node = next_node-&gt;pre;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (next_node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				cur_task = next_node;</span><br><span class="line">				<span class="keyword">if</span> (cur_task-&gt;task.isFirstRun) &#123;</span><br><span class="line">					<span class="comment">//切换的任务为第一次进入调度</span></span><br><span class="line">					cur_task-&gt;status = TASK_EXEC;</span><br><span class="line">					cur_task-&gt;task.isFirstRun = <span class="number">0</span>;</span><br><span class="line">					<span class="comment">//由于任务第一次运行, 直接从函数入口地址开始运行</span></span><br><span class="line">					usart1_send_string(<span class="string">&quot;start_task\r\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">					start_task((<span class="type">int</span>)cur_task-&gt;task.cur_stack, <span class="number">0xFFFFFFF9</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//切换的任务不是第一次进入调度, 需要从上一次中断的地方开始运行</span></span><br><span class="line">					cur_task-&gt;status = TASK_EXEC;</span><br><span class="line">					usart1_send_string(<span class="string">&quot;resume_task\r\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">					resume_task((<span class="type">int</span>)cur_task-&gt;task.cur_stack, <span class="number">0xFFFFFFF9</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//找不到任何可以调度的任务, 恢复到IDLEtask</span></span><br><span class="line">				cur_task = idle_task;</span><br><span class="line">				cur_task-&gt;status = TASK_EXEC;</span><br><span class="line">				resume_task((<span class="type">int</span>)cur_task-&gt;task.cur_stack, <span class="number">0xFFFFFFF9</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中启动任务的函数就是start_task这个函数, 这个函数是内联汇编函数, 传入两个参数, 一个是任务栈指针一个是LR寄存器, 代码如下</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __asm <span class="type">void</span> <span class="title function_">start_task</span><span class="params">(<span class="type">int</span> <span class="built_in">stack</span>, <span class="type">int</span> lr_)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//R0是栈指针, R1是返回地址</span></span><br><span class="line">	<span class="comment">//从任务栈中将R4-R11读出来写入寄存器</span></span><br><span class="line">	LDMIA R0!, &#123;R4-R11&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//更新SP</span></span><br><span class="line">	MSR MSP, R0</span><br><span class="line"></span><br><span class="line">	<span class="comment">//触发硬件中断返回</span></span><br><span class="line">	BX R1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在前面提到, ARM的中断函数中,CPU会自动保存一部分寄存器, 然后软件再保存一部分, 那么当中断退出的时候, 寄存器又是怎么恢复的呢, 实际上, 当CPU进入中断的时候, LR寄存器并不会指向中断来临前的地址,而是会被赋一个特殊的值, 0xFFFFFFF9, 中断退出时, CPU跳转到该地址, 将栈中的数据恢复到PSR, PC, LR, R12, R0-R3这些寄存器上去, 所以启动任务实际上就是模拟退出中断的过程, 首先从目标任务栈中恢复R4-R11寄存器, 然后把当前栈指针更新为目标任务的栈指针, 最后跳转到0xFFFFFFF9, 硬件恢复寄存器</strong></p>
<h3 id="3-切换任务"><a href="#3-切换任务" class="headerlink" title="3. 切换任务"></a>3. 切换任务</h3><p><strong>当系统从主栈进入第一个任务栈后, 后续的所有任务的切换全是从当前任务栈切换到下一个任务的任务栈, 和从主栈切换到任务栈不同的是, 从主栈切换到任务栈不需要保存主栈的栈帧, 直接切换到任务栈就行, 因为开始调度任务后永远不会回到主栈, 但是从一个任务栈切换到另一个任务栈之后还是会调度回当前的任务, 所以需要切换前保存当前的栈帧</strong></p>
<p><strong>本RTOS里, 在SysTick_Handler_asm函数中, 对在调用SysTick_Handler之前进行了栈帧的保护, 代码如下:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SysTick_Handler_asm PROC</span><br><span class="line">				; 保存现场</span><br><span class="line">				IMPORT |cur_task|		;cur_task是外部定义的指向当前任务的指针</span><br><span class="line">				LDR R0, =|cur_task|		;R0 = &amp;cur_task 获得指针的地址</span><br><span class="line">				LDR R0, [R0, #0]		;R0 = *R0		解引用指针</span><br><span class="line">				CMP R0, #0				;将该指针指向的值和0相比较</span><br><span class="line">				BEQ DO_NOT_SAVE_STACK	;如果等于0的话说明指针为NULL, 当前为主栈直接跳转到DO_NOT_SAVE_STACK,不进行栈帧的保存</span><br><span class="line">				</span><br><span class="line">SAVE_OLD_STACK</span><br><span class="line">				STMDB SP!, &#123;R4-R11&#125;		;软件将R4-R11保存至栈中</span><br><span class="line">				LDR R0, =|cur_task|		;获取指针的地址</span><br><span class="line">				LDR R0, [R0, #0]		;获取指针指向的TCB的地址</span><br><span class="line">				STR SP, [R0, #0x1c]		;将当前SP栈寄存器保存到TCB*-&gt;cur_stack中</span><br><span class="line">				</span><br><span class="line">DO_NOT_SAVE_STACK</span><br><span class="line">				BL 		SysTick_Handler</span><br><span class="line">				ENDP</span><br></pre></td></tr></table></figure>

<p><strong>STR SP, [R0, #0x1c]这一步为什么是0x1c, 这要从TCB结构体的定义说起</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	TASK_FUNCTION f;		<span class="comment">//任务入口函数</span></span><br><span class="line">	<span class="type">void</span>* param;			<span class="comment">//任务参数</span></span><br><span class="line">	TASK_PRIORITY priority; <span class="comment">//任务优先级</span></span><br><span class="line">	<span class="type">uint8_t</span> *stack_base; 	<span class="comment">//任务栈基地址</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *task_name;	<span class="comment">//任务名</span></span><br><span class="line">	<span class="type">uint32_t</span> stack_size;	<span class="comment">//任务栈大小</span></span><br><span class="line">	<span class="type">uint32_t</span> *stack_top;	<span class="comment">//任务栈顶</span></span><br><span class="line">	<span class="type">uint32_t</span> *cur_stack;	<span class="comment">//当前栈指针</span></span><br><span class="line">	<span class="type">uint8_t</span> isFirstRun;		<span class="comment">//是否第一次运行</span></span><br><span class="line">&#125;TASK_TCB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">	TASK_DISABLED = <span class="number">0x0</span>,	<span class="comment">//禁止调度</span></span><br><span class="line">	TASK_READY = <span class="number">0x1</span>,		<span class="comment">//准备好调度</span></span><br><span class="line">	TASK_EXEC,				<span class="comment">//正在运行</span></span><br><span class="line">	TASK_TERM,				<span class="comment">//挂起</span></span><br><span class="line">	TASK_DELAY,				<span class="comment">//延时</span></span><br><span class="line">&#125;TASK_STATUS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TASK_NODE</span>&#123;</span></span><br><span class="line">	TASK_TCB task;			<span class="comment">//任务控制块</span></span><br><span class="line">	TASK_STATUS status;		<span class="comment">//任务状态</span></span><br><span class="line">	<span class="type">uint32_t</span> delay_tick;	<span class="comment">//延时的tick</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">TASK_NODE</span> *<span class="title">pre</span>;</span>	<span class="comment">//上一个任务节点 低优先级</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">TASK_NODE</span> *<span class="title">next</span>;</span>	<span class="comment">//下一个任务节点 高优先级</span></span><br><span class="line">&#125;TASK_NODE;</span><br></pre></td></tr></table></figure>

<p><strong>TASK_NODE中TASK_TCB的偏移为0, 而在TASK_TCB中cur_stack的偏移为28字节, 前面有6个指针变量和一个4字节的枚举, 总共28字节, 十六进制表示为0x1c, 所以将SP寄存器需要保存在cur_task+0x1c位置的地方</strong></p>
<p><img src="https://pic.imgdb.cn/item/6482c6ff1ddac507cc84350d.gif" alt="GIF 2023-6-9 14-29-37"></p>
<h2 id="4-如何优化调度器"><a href="#4-如何优化调度器" class="headerlink" title="4. 如何优化调度器"></a>4. 如何优化调度器</h2><h2 id="5-添加定时器模块"><a href="#5-添加定时器模块" class="headerlink" title="5. 添加定时器模块"></a>5. 添加定时器模块</h2><h2 id="6-添加互斥锁"><a href="#6-添加互斥锁" class="headerlink" title="6. 添加互斥锁"></a>6. 添加互斥锁</h2><h2 id="7-添加信号量"><a href="#7-添加信号量" class="headerlink" title="7. 添加信号量"></a>7. 添加信号量</h2><h2 id="8-TODO"><a href="#8-TODO" class="headerlink" title="8. TODO"></a>8. TODO</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E8%87%AA%E5%88%B6RTOS/" data-id="cliqq13m30001hcm39za95b11" data-title="从零开始自制RTOS" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RTOS/" rel="tag">RTOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/STM32/" rel="tag">STM32</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/08/12/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          嵌入式Linux-系统调用
        
      </div>
    </a>
  
  
    <a href="/2023/06/09/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/">嵌入式开发</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ARM/" rel="tag">ARM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E5%86%85%E6%A0%B8/" rel="tag">Linux内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RTOS/" rel="tag">RTOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STM32/" rel="tag">STM32</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD/" rel="tag">中断</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ARM/" style="font-size: 20px;">ARM</a> <a href="/tags/Linux%E5%86%85%E6%A0%B8/" style="font-size: 20px;">Linux内核</a> <a href="/tags/RTOS/" style="font-size: 10px;">RTOS</a> <a href="/tags/STM32/" style="font-size: 10px;">STM32</a> <a href="/tags/%E4%B8%AD%E6%96%AD/" style="font-size: 10px;">中断</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/12/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F/">嵌入式Linux-中断子系统</a>
          </li>
        
          <li>
            <a href="/2023/08/12/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/">嵌入式Linux-系统调用</a>
          </li>
        
          <li>
            <a href="/2023/06/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E8%87%AA%E5%88%B6RTOS/">从零开始自制RTOS</a>
          </li>
        
          <li>
            <a href="/2023/06/09/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>